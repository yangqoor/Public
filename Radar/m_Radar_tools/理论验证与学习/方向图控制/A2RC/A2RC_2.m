%--------------------------------------------------------------------------
%   初始化
%--------------------------------------------------------------------------
clear;clc;

%--------------------------------------------------------------------------
%   参数设置
%--------------------------------------------------------------------------
N = 64;                                                                     %阵元个数
theta = 0;                                                                %期望的天线指向
Omega_M = [-2.5 2.5]+theta;                                                   %主瓣方向拟合角度范围
Omega_S = Omega_M + [-0 0];                                                 %旁瓣控制范围
%--------------------------------------------------------------------------
%   生成参数
%--------------------------------------------------------------------------
lambda = 1;                                                                 %波长
dd = lambda/2;                                                              %阵元间距d = lambda/2
d = 0:dd:(N-1)*dd;                                                          %构建阵列坐标
angle_axis = -90:0.1:90;

%--------------------------------------------------------------------------
%   期望天线方向图
%--------------------------------------------------------------------------
window_N = taylorwin(N);
w_win = window_N.*exp(1j.*2*pi*d.'*sind(theta));

[L_d,L_d_P,L_d_dB] = L_norm_array_pattern(w_win,angle_axis);                %期望天线方向图

st = find(Omega_M(1) == angle_axis);
en = find(Omega_M(2) == angle_axis);
L_d_dB(1:st-1) = -31;
L_d_dB(en+1:end) = -31;

%--------------------------------------------------------------------------
%   零陷放置角度
%--------------------------------------------------------------------------
index = find(10 == angle_axis);
L_d_dB(index-17:index+17) = -31 + -20.*hann(35);

index = find(30 == angle_axis);
L_d_dB(index-17:index+17) = -31 + -20.*hann(35);
% L_d_dB(1:81) = linspace(-35,-30,81);

%--------------------------------------------------------------------------
%   初始导向矢量
%--------------------------------------------------------------------------
A = exp(1j.*2*pi*d.'*sind(theta));
w = window_N.*A;
% w = A;
[L,L_P,L_dB] = L_norm_array_pattern(w,angle_axis);

%--------------------------------------------------------------------------
%   确定角度搜索范围
%--------------------------------------------------------------------------
max_theta = 0;
k = 2;
while(1)
    %----------------------------------------------------------------------
    %   计算主瓣的功率差异值
    %----------------------------------------------------------------------
    st_m = find(Omega_M(1) == angle_axis);                                  %确定角度范围首末坐标
    en_m = find(Omega_M(2) == angle_axis);
    L_diff_dB_m = abs(L_dB - L_d_dB);                                          %主瓣差异
    [value_m,max_theta_index_m] = max(L_diff_dB_m(st_m:en_m));               %计算主瓣的功率差异值
    
    %----------------------------------------------------------------------
    %   更新搜索到的主瓣的角度
    %----------------------------------------------------------------------
    max_theta_index_m = st_m + max_theta_index_m - 1;
    max_theta_m = angle_axis(max_theta_index_m);
    
    %----------------------------------------------------------------------
    %   计算副瓣的功率差异值
    %----------------------------------------------------------------------
    st_s = find(Omega_S(1) == angle_axis);st_s = st_s - 1;
    en_s = find(Omega_S(2) == angle_axis);en_s = en_s + 1;
    L_diff_dB_s = L_dB - L_d_dB;
    %----------------------------------------------------------------------
    %   更新搜索到的副瓣的角度
    %----------------------------------------------------------------------
    [value1,max_theta_index1] = max(L_diff_dB_s(1:st_s));
    [value2,max_theta_index2] = max(L_diff_dB_s(en_s:end));
    if value1>value2
        value_s = value1;
        max_theta_index_s = max_theta_index1;
    else
        value_s = value2;
        max_theta_index2 = en_s + max_theta_index2 - 1;
        max_theta_index_s = max_theta_index2;
    end
    max_theta_s = angle_axis(max_theta_index_s);
    

    %----------------------------------------------------------------------
    %   如果主瓣差异过大 调节主瓣 否则调节副瓣
    %----------------------------------------------------------------------
    if value_m > 5                                                          %主瓣误差在1dB以内
        disp(['[' num2str(k,'%03d') '] -> ' '调节 [主] 瓣'])  
        max_theta = max_theta_m;
        rho_k = db2pow(L_d_dB(max_theta_index_m));                          %更新期望值dB
        w(:,k) = exp(1j.*2*pi*d.'*sind(max_theta));                         %生成导向矢量
        A(:,k) = exp(1j.*2*pi*d.'*sind(max_theta));                         %生成导向矢量
    %----------------------------------------------------------------------
    %   否则调节副瓣
    %----------------------------------------------------------------------
    else
        disp(['[' num2str(k,'%03d') '] -> ' '调节 [副] 瓣']) 
        %------------------------------------------------------------------
        %   如果副瓣误差<0.5dB 退出
        %------------------------------------------------------------------
        if value_s < 0.3
            disp([value_s max_theta_s])
            break
        end
        max_theta = max_theta_s;
        rho_k = db2pow(L_d_dB(max_theta_index_s));                          %更新期望值dB
        w(:,k) = exp(1j.*2*pi*d.'*sind(max_theta));                         %生成导向矢量
        A(:,k) = exp(1j.*2*pi*d.'*sind(max_theta));
    end
 
    %----------------------------------------------------------------------
    %   计算系数
    %----------------------------------------------------------------------
    P_k(k-1) = abs(w(:,k-1)'*A(:,k)).^2;
    P_1(k-1) = abs(w(:,k-1)'*A(:,1)).^2;
    v_k1 = A(:,k)'*A(:,1);
    d_k = w(:,k-1)' * A(:,k) * norm(A(:,k))^2-rho_k*w(:,k-1)'*A(:,1)*v_k1;
    
    Q(:,:,k) = [P_k(k-1) - rho_k*P_1(k-1) ...
                d_k; ...
                conj(d_k)...
                norm(A(:,k))^4 - rho_k*abs(v_k1).^2];
    %----------------------------------------------------------------------
    %   圆心与半径
    %----------------------------------------------------------------------
    c(:,k) = 1/Q(2,2,k)*[-real(Q(1,2,k)) + 1j.*imag(Q(1,2,k))];
    r(k) = real(sqrt(-det(Q(:,:,k))))/abs(Q(2,2,k));
    %----------------------------------------------------------------------
    %   最优系数
    %----------------------------------------------------------------------
    u(k) = (norm(c(:,k))-r(k))/norm(c(:,k))*c(:,k);                             %最佳系数
    %----------------------------------------------------------------------
    %   更新
    %----------------------------------------------------------------------
    w(:,k) = w(:,k-1) + u(k).* A(:,k);
    [L,L_P,L_dB] = L_norm_array_pattern(w(:,k),angle_axis);
    k = k + 1;
    
    if k>=1000
        disp('无法收敛')
        break
    end
    %----------------------------------------------------------------------
    %   可视化
    %----------------------------------------------------------------------
    
    figure(1);
    plot(angle_axis,[L_dB;L_d_dB],'LineWidth',2);grid on;hold on
    plot([max_theta max_theta],[-100 1],'LineWidth',1.5);hold off
    axis([-90 90 -70 0])
    drawnow
%     pause
end
figure(1);
plot(angle_axis,[L_dB;L_d_dB],'LineWidth',2);grid on;hold on
plot([max_theta max_theta],[-100 1],'LineWidth',1.5);hold off
axis([-90 90 -70 0])
drawnow
legend('更新方向图','期望方向图','调节点')