%--------------------------------------------------------------------------
%   张正友校准算法
%   输入内参矩阵(matlab输出的内参矩阵需要转至)
%   输入径向畸变的系数k1 k2
%   没有对彩色rgb适配,这里仅对黑白照片处理
%   水平方向u
%   垂直方向v
%   example：
%   [uimxy,u,v] = undistortImage2(imxy,cameraParams.IntrinsicMatrix.',cameraParams.RadialDistortion);
%--------------------------------------------------------------------------
function [undistorted_img,...
        pixel_trans_u,...
        pixel_trans_v] = undistortImage2(img, K, D)
[height, width,~] = size(img);                                               %获取图片尺寸
fx = K(1,1);                                                                %内参矩阵 x方向比例因子
fy = K(2,2);                                                                %内参矩阵 y方向比例因子
cx = K(1,3);                                                                %x方向像素偏移补偿
cy = K(2,3);                                                                %y方向像素偏移补偿

undistorted_img = eval([data_type '(zeros(size(img)))']);                   %矫正后缓冲数据
pixel_trans_u = zeros(height,width);
pixel_trans_v = zeros(height,width);
%--------------------------------------------------------------------------
%   图像原始坐标索引点
%--------------------------------------------------------------------------
[X,Y] = meshgrid(1:width,1:height);                                         %X Y 表示水平 垂直方向坐标

%--------------------------------------------------------------------------
%   内参矩阵归一化畸变矫正坐标
%--------------------------------------------------------------------------
X1 = (X-cx)./fx;
Y1 = (Y-cy)./fy;

%--------------------------------------------------------------------------
%   径向畸变模型得到归一化的畸变坐标
%--------------------------------------------------------------------------
R2 = X1.^2+Y1.^2;
X2 = X1.*(1+D(1).*R2+D(2).*R2.^2);
Y2 = Y1.*(1+D(1).*R2+D(2).*R2.^2);

%--------------------------------------------------------------------------
%   重新映射坐标到原始图像
%--------------------------------------------------------------------------
u_distorted = fx.*X2 + cx;                                                  %图像的行坐标
v_distorted = fy.*Y2 + cy;                                                  %图像的列坐标

%--------------------------------------------------------------------------
%   坐标越界处理
%--------------------------------------------------------------------------
%   水平方向
%--------------------------------------------------------------------------
u_distorted(u_distorted<1)=nan;
u_distorted(u_distorted>width)=nan;

%--------------------------------------------------------------------------
%   垂直方向
%--------------------------------------------------------------------------
v_distorted(v_distorted<1)=nan;
v_distorted(v_distorted>height)=nan;

%--------------------------------------------------------------------------
%   重新填充像素
%--------------------------------------------------------------------------
for xdx = 1:width
    for ydx = 1:height
        if isnan(u_distorted(ydx,xdx)) || isnan(v_distorted(ydx,xdx))
            continue
        else
            %   应该采用最邻近插值,这里偷懒直接选择最靠近的像素填充
            undistorted_img(ydx,xdx,:) = img(round(v_distorted(ydx,xdx)),round(u_distorted(ydx,xdx)),:);
            pixel_trans_u(ydx,xdx) = u_distorted(ydx,xdx);
            pixel_trans_v(ydx,xdx) = v_distorted(ydx,xdx);
        end
    end
end
