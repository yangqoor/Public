<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- /fasttmp/mkdist-qt-4.3.5-1211793125/qtopia-core-opensource-src-4.3.5/doc/src/styles.qdoc -->
<head>
  <title>Qt 4.3: Implementing Styles and Style Aware Widgets</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><a href="http://www.trolltech.com"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></a></td></tr></table><h1 align="center">Implementing Styles and Style Aware Widgets<br /><small></small></h1>
<ul><li><a href="#introduction">Introduction</a></li>
<li><a href="#the-qstyle-implementation">The QStyle implementation</a></li>
<ul><li><a href="#the-style-elements">The Style Elements</a></li>
<ul><li><a href="#primitive-elements">Primitive Elements</a></li>
<li><a href="#control-elements">Control Elements</a></li>
<li><a href="#complex-control-elements">Complex Control Elements</a></li>
<li><a href="#other-qstyle-tasks">Other QStyle Tasks</a></li>
</ul>
<li><a href="#style-options">Style Options</a></li>
<li><a href="#qstyle-functions">QStyle Functions</a></li>
<li><a href="#the-palette">The Palette</a></li>
<li><a href="#implementation-issues">Implementation Issues</a></li>
</ul>
<li><a href="#java-style">Java Style</a></li>
<ul><li><a href="#design-and-implementation">Design and Implementation</a></li>
<li><a href="#limitations-and-differences-from-java">Limitations and Differences from Java</a></li>
<li><a href="#styling-java-check-boxes">Styling Java Check Boxes</a></li>
</ul>
<li><a href="#widget-walkthrough">Widget Walkthrough</a></li>
<ul><li><a href="#common-widget-properties">Common Widget Properties</a></li>
<li><a href="#widget-reference">Widget Reference</a></li>
<ul><li><a href="#push-buttons">Push Buttons</a></li>
<li><a href="#check-and-radio-buttons">Check and Radio Buttons</a></li>
<li><a href="#tabs">Tabs</a></li>
<li><a href="#scroll-bars">Scroll Bars</a></li>
<li><a href="#sliders">Sliders</a></li>
<li><a href="#spin-boxes">Spin Boxes</a></li>
<li><a href="#title-bar">Title Bar</a></li>
<li><a href="#combo-box">Combo Box</a></li>
<li><a href="#group-boxes">Group Boxes</a></li>
<li><a href="#splitters">Splitters</a></li>
<li><a href="#progress-bar">Progress Bar</a></li>
<li><a href="#tool-buttons">Tool Buttons</a></li>
<li><a href="#toolbars">Toolbars</a></li>
<li><a href="#menus">Menus</a></li>
<li><a href="#menu-bar">Menu Bar</a></li>
<li><a href="#item-view-headers">Item View Headers</a></li>
<li><a href="#tree-branch-indicators">Tree Branch Indicators</a></li>
<li><a href="#tool-boxes">Tool Boxes</a></li>
<li><a href="#size-grip">Size Grip</a></li>
<li><a href="#rubber-band">Rubber Band</a></li>
<li><a href="#dock-widgets">Dock Widgets</a></li>
</ul>
</ul>
</ul>
<a name="introduction"></a>
<h3>Introduction</h3>
<p>Styles (classes that inherit <a href="qstyle.html">QStyle</a>) draw on behalf of widgets and encapsulate the look and feel of a GUI. Several styles are built into Qt (e.g&#x2e;, windows style and motif style). Other styles are only available on specific platforms (such as the windows XP style). Custom styles are made available as plugins or by creating an instance of the style class in an application and setting it with <a href="qapplication.html#setStyle">QApplication::setStyle</a>().</p>
<p>To implement a new style, you inherit one of Qt's existing styles - the one most resembling the style you want to create - and reimplement a few virtual functions. This process is somewhat involved, and we therefore provide this overview. We give a step-by-step walkthrough of how to style individual Qt widgets. We will examine the <a href="qstyle.html">QStyle</a> virtual functions, member variables, and enumerations.</p>
<p>The part of this document that does not concern the styling of individual widgets is meant to be read sequentially because later sections tend to depend on earlier ones. The description of the widgets can be used for reference while implementing a style. However, you may need to consult the Qt source code in some cases. The sequence in the styling process should become clear after reading this document, which will aid you in locating relevant code.</p>
<p>To develop style aware widgets (i.e&#x2e;, widgets that conform to the style in which they are drawn), you need to draw them using the current style. This document shows how widgets draw themselves and which possibilities the style gives them.</p>
<a name="the-qstyle-implementation"></a>
<h3>The QStyle implementation</h3>
<p>The API of <a href="qstyle.html">QStyle</a> contains functions that draw the widgets, static helper functions to do common and difficult tasks (e.g&#x2e;, calculating the position of slider handles) and functions to do the various calculations necessary while drawing (e.g&#x2e;, for the widgets to calculate their size hints). The style also help some widgets with the layout of their contents. In addition, it creates a <a href="qpalette.html">QPalette</a> that contains <a href="qbrush.html">QBrush</a>es to draw with.</p>
<p><a href="qstyle.html">QStyle</a> draws graphical elements; an element is a widget or a widget part like a push button bevel, a window frame, or a scroll bar. When a widget asks a style to draw an element, it provides the style with a style option, which is a class that contains the information necessary for drawing.</p>
<p>We will in the course of this section look at the style elements, the style options, and the functions of <a href="qstyle.html">QStyle</a>. Finally, we describe how the palette is used.</p>
<p>Not all drawing is performed by the <a href="qstyle.html">QStyle</a> implementation; the items in item views are drawn by <a href="model-view-delegate.html">delegates</a> (classes that inherit <a href="qabstractitemdelegate.html">QAbstractItemDelegate</a>). The item view headers are still drawn by the style. In this document we only describe how to implement a <a href="qstyle.html">QStyle</a> subclass, so we do not treat item view related parts of the drawing. In order to get absolute control over the painting of widgets, you need to implement your own delegates for the item views. Note that delegates must be set programmatically for each individual widget (i.e&#x2e;, default delegates cannot be provided as plugins). This architecture has mainly been chosen for performance reasons.</p>
<a name="the-style-elements"></a>
<h4>The Style Elements</h4>
<p>A style element is a graphical part of a GUI. A widget consists of a hierarchy (or tree) of style elements. For instance, when a style receives a request to draw a push button (from <a href="qpushbutton.html">QPushButton</a>, for example), it draws a label (text and icon), a button bevel, and a focus frame. The button bevel, in turn, consists of a frame around the bevel and two other elements, which we will look at later. Below is a conceptual illustration of the push button element tree. We will see the actual tree for <a href="qpushbutton.html">QPushButton</a> when we go through the individual widgets.</p>
<p align="center"><img src="images//conceptualpushbuttontree.png" /></p><p>Widgets are not necessarily drawn by asking the style to draw only one element. Widgets can make several calls to the style to draw different elements. An example is <a href="qtabwidget.html">QTabWidget</a>, which draws its tabs and frame individually.</p>
<p>There are three element types: primitive elements, control elements, and complex control elements. The elements are defined by the <a href="qstyle.html#ComplexControl-enum">ComplexControl</a>, <a href="qstyle.html#ControlElement-enum">ControlElement</a>, and <a href="qstyle.html#PrimitiveElement-enum">PrimitiveElement</a> enums. The values of each element enum has a prefix to identify their type: <tt>CC_</tt> for complex elements, <tt>CE_</tt> for control elements, and <tt>PE_</tt> for primitive elements. We will in the following three sections see what defines the different elements and see examples of widgets that use them.</p>
<p>The <a href="qstyle.html">QStyle</a> class description contains a list of these elements and their roles in styling widgets. We will see how they are used when we style individual widgets.</p>
<a name="primitive-elements"></a>
<h5>Primitive Elements</h5>
<p>Primitive elements are GUI elements that are common and often used by several widgets. Examples of these are frames, button bevels, and arrows for spin boxes, scroll bars, and combo boxes. Primitive elements cannot exist on their own: they are always part of a larger construct. They take no part in the interaction with the user, but are passive decorations in the GUI.</p>
<a name="control-elements"></a>
<h5>Control Elements</h5>
<p>A control element performs an action or displays information to the user. Examples of control elements are push buttons, check boxes, and header sections in tables and tree views. Control elements are not necessarily complete widgets such as push buttons, but can also be widget parts such as tab bar tabs and scroll bar sliders. They differ from primitive elements in that they are not passive, but fill a function in the interaction with the user. Controls that consist of several elements often use the style to calculate the bounding rectangles of the elements. The available sub elements are defined by the <a href="qstyle.html#SubElement-enum">SubElement</a> enum. This enum is only used for calculating bounding rectangles, and sub elements are as such not graphical elements to be drawn like primitive, control, and complex elements.</p>
<a name="complex-control-elements"></a>
<h5>Complex Control Elements</h5>
<p>Complex control elements contain sub controls. Complex controls behave differently depending on where the user handles them with the mouse and which keyboard keys are pressed. This is dependent on which sub control (if any) that the mouse is over or received a mouse press. Examples of complex controls are scroll bars and combo boxes. With a scroll bar, you can use the mouse to move the slider and press the line up and line down buttons. The available sub controls are defined by the <a href="qstyle.html">SubControl</a> enum.</p>
<p>In addition to drawing, the style needs to provide the widgets with information on which sub control (if any) a mouse press was made on. For instance, a <a href="qscrollbar.html">QScrollBar</a> needs to know if the user pressed the slider, the slider groove, or one of the buttons.</p>
<p>Note that sub controls are not the same as the control elements described in the previous section. You cannot use the style to draw a sub control; the style will only calculate the bounding rectangle in which the sub control should be drawn. It is common, though, that complex elements use control and primitive elements to draw their sub controls, which is an approach that is frequently used by the built-in styles in Qt and also the Java style. For instance, the Java style uses PE_IndicatorCheckBox to draw the check box in group boxes (which is a sub control of CC_GroupBox). Some sub controls have an equivalent control element, e.g&#x2e;, the scroll bar slider (SC_SCrollBarSlider and CE_ScrollBarSlider).</p>
<a name="other-qstyle-tasks"></a>
<h5>Other QStyle Tasks</h5>
<p>The style elements and widgets, as mentioned, use the style to calculate bounding rectangles of sub elements and sub controls, and pixel metrics, which is a style dependent size in screen pixels, for measures when drawing. The available rectangles and pixel metrics are represented by three enums in <a href="qstyle.html">QStyle</a>: <a href="qstyle.html#SubElement-enum">SubElement</a>, <a href="qstyle.html#SubControl-enum">SubControl</a>, and <a href="qstyle.html#PixelMetric-enum">PixelMetric</a>. Values of the enums can easily by identified as they start with SE_, SC_ and PM_.</p>
<p>The style also contain a set of style hints, which is represented as values in the <a href="qstyle.html#StyleHint-enum">StyleHint</a> enum. All widgets do not have the same functionality and look in the different styles. For instance, when the menu items in a menu do not fit in a single column on the screen, some styles support scrolling while others draw more than one column to fit all items.</p>
<p>A style usually has a set of standard images (such as a warning, a question, and an error image) for message boxes, file dialogs, etc. <a href="qstyle.html">QStyle</a> provides the <a href="qstyle.html#StandardPixmap-enum">StandardPixmap</a> enum. Its values represent the standard images. Qt's widgets use these, so when you implement a custom style you should supply the images used by the style that is being implemented.</p>
<p>The style calculates the spacing between widgets in layouts. There are two ways the style can handle these calculations. You can set the PM_LayoutHorizontalSpacing and PM_LayoutVerticalSpacing, which is the way the java style does it (through <a href="qcommonstyle.html">QCommonStyle</a>). Alternatively, you can implement <a href="qstyle.html#layoutSpacing">QStyle::layoutSpacing</a>() and <a href="qstyle.html#layoutSpacingImplementation">QStyle::layoutSpacingImplementation</a>() if you need more control over this part of the layout. In these functions you can calculate the spacing based on control types (<a href="qsizepolicy.html#ControlType-enum">QSizePolicy::ControlType</a>) for different size policies (<a href="qsizepolicy.html#Policy-enum">QSizePolicy::Policy</a>) and also the style option for the widget in question.</p>
<a name="style-options"></a>
<h4>Style Options</h4>
<p>A style option (a class that inherit <a href="qstyleoption.html">QStyleOption</a>) stores parameters used by <a href="qstyle.html">QStyle</a> functions. The sub-classes of <a href="qstyleoption.html">QStyleOption</a> contain all information necessary to style the individual widgets. The style options keep public variables for performance reasons. Style options are filled out by the widgets.</p>
<p>The widgets can be in a number of different states, which are defined by the <a href="qstyle.html#StateFlag-enum">State</a> enum. Some of the state flags have different meanings depending on the widget, but others are common for all widgets like State_Disabled. It is <a href="qstyleoption.html">QStyleOption</a> that sets the common states with <a href="qstyleoption-obsolete.html#init">QStyleOption::init</a>(); the rest of the states are set by the individual widgets.</p>
<p>Most notably, the style options contain the palette and bounding rectangles of the widgets to be drawn. Most widgets have specialized style options. <a href="qpushbutton.html">QPushButton</a> and <a href="qcheckbox.html">QCheckBox</a>, for instance, use <a href="qstyleoptionbutton.html">QStyleOptionButton</a> as style option, which contain the text, icon, and the size of their icon. The exact contents of all options are described when we go through individual widgets.</p>
<a name="qstyle-functions"></a>
<h4>QStyle Functions</h4>
<p>The <a href="qstyle.html">QStyle</a> class defines three functions for drawing the primitive, control, and complex elements: <a href="qstyle.html#drawPrimitive">drawPrimitive()</a>, <a href="qstyle.html#drawControl">drawControl()</a>, and <a href="qstyle.html#drawComplexControl">drawComplexControl()</a>. The functions takes the following parameters:</p>
<ul>
<li>the enum value of the element to draw</li>
<li>a <a href="qstyleoption.html">QStyleOption</a> which contains the information needed to draw the element.</li>
<li>a <a href="qpainter.html">QPainter</a> with which to draw the element.</li>
<li>a pointer to a <a href="qwidget.html">QWidget</a>, typically the widget that the element is painted on.</li>
</ul>
<p>Not all widgets send a pointer to themselves. If the style option sent to the function does not contain the information you need, you should check the widget implementation to see if it sends a pointer to itself.</p>
<p>The <a href="qstyle.html">QStyle</a> class also provides helper functions that are used when drawing the elements. The <a href="qstyle.html#drawItemText">drawItemText()</a> function draws text within a specified rectangle and taking a <a href="qpalette.html">QPalette</a> as a parameter. The <a href="qstyle.html#drawItemPixmap">drawItemPixmap()</a> function helps to align a pixmap within a specified bounding rectangle.</p>
<p>Other <a href="qstyle.html">QStyle</a> functions do various calculations for the functions that draw. The widgets also use these functions for calculating size hints and also for bounding rectangle calculations if they draw several style elements themselves. As with the functions that draw elements the helper functions typically takes the same arguments.</p>
<ul>
<li>The <a href="qstyle.html#subElementRect">subElementRect()</a> function takes a <a href="qstyle.html#SubElement-enum">SubElement</a> enum value, and calculates a bounding rectangle for a sub element. The style uses this function to know where to draw the different parts of an element. This is mainly done for reuse. If you create a new style, you can use the same location of sub elements as the super class.</li>
<li>The <a href="qstyle.html#subControlRect">subControlRect()</a> function is used to calculate bounding rectangles for sub controls in complex controls. When you implement a new style, you reimplement <tt>subControlRect()</tt> and calculate the rectangles that are different from the super class.</li>
<li>The <a href="qstyle.html#pixelMetric">pixelMetric()</a> function returns a pixel metric, which is a style dependent size given in screen pixels. It takes a value of the <a href="qstyle.html#PixelMetric-enum">PixelMetric</a> enum and returns the correct measure. Note that pixel metrics do not necessarily have to be static measures, but can be calculated with, for example, the style option.</li>
<li>The <a href="qstyle.html#hitTestComplexControl">hitTestComplexControl()</a> function returns the sub control that the mouse pointer is over in a complex control. Usually, this is simply a matter of using <a href="qstyle.html#subControlRect">subControlRect()</a> to get the bounding rectangles of the sub controls, and see which rectangle contains the position of the cursor.</li>
</ul>
<p><a href="qstyle.html">QStyle</a> also have the functions <a href="qstyle.html#polish">polish()</a> and <a href="qstyle.html#unpolish">unpolish()</a>. All widgets are sent to the <tt>polish()</tt> function before being shown and to <tt>unpolish()</tt> when they are hidden. You can use these functions to set attributes on the widgets or do other work that is required by your style. For instance, if you need to know when the mouse is hovering over the widget, you need to set the <a href="qt.html#WidgetAttribute-enum">WA_Hover</a> widget attribute. The State_MouseOver state flag will then be set in the widget's style options.</p>
<p><a href="qstyle.html">QStyle</a> has a few static helper functions that do some common and difficult tasks. They can calculate the position of a slider handle from the value of the slider and transform rectangles and draw text considering reverse layouts; see the <a href="qstyle.html">QStyle</a> class documentation for more details.</p>
<p>The usual approach when one reimplements <a href="qstyle.html">QStyle</a> virtual functions is to do work on elements that are different from the super class; for all other elements, you can simply use the super class implementation.</p>
<a name="the-palette"></a>
<h4>The Palette</h4>
<p>Each style provides a color - that is, <a href="qbrush.html">QBrush</a> - palette that should be used for drawing the widgets. There is one set of colors for the different widget states (<a href="qpalette.html#ColorGroup-enum">QPalette::ColorGroup</a>): active (widgets in the window that has keyboard focus), inactive (widgets used for other windows), and disabled (widgets that are set disabled). The states can be found by querying the State_Active and State_Enabled state flags. Each set contains color certain roles given by the <a href="qpalette.html#ColorRole-enum">QPalette::ColorRole</a> enum. The roles describe in which situations the colors should be used (e.g&#x2e;, for painting widget backgrounds, text, or buttons).</p>
<p>How the color roles are used is up to the style. For instance, if the style uses gradients, one can use a palette color and make it darker or lighter with <a href="qcolor.html#darker">QColor::darker</a>() and <a href="qcolor.html#lighter">QColor::lighter</a>() to create the gradient. In general, if you need a brush that is not provided by the palette, you should try to derive it from one.</p>
<p><a href="qpalette.html">QPalette</a>, which provides the palette, stores colors for different widget states and color roles. The palette for a style is returned by <a href="qstyle.html#standardPalette">standardPalette()</a>. The standard palette is not installed automatically when a new style is set on the application (<a href="qapplication.html#setStyle">QApplication::setStyle</a>()) or widget (<a href="qwidget.html#setStyle">QWidget::setStyle</a>()), so you must set the palette yourself with (<a href="qapplication.html#setPalette">QApplication::setPalette</a>()) or (<a href="qwidget.html#palette-prop">QWidget::setPalette</a>()).</p>
<p>It is not recommended to hard code colors as applications and individual widgets can set their own palette and also use the styles palette for drawing. Note that none of Qt's widgets set their own palette. The java style does hard code some colors, but its author looks past this in silence. Of course, it is not intended that the style should look good with any palette.</p>
<a name="implementation-issues"></a>
<h4>Implementation Issues</h4>
<p>When you implement styles, there are several issues to consider. We will give some hints and advice on implementation here.</p>
<p>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles virtual functions can affect the state of the drawing (e.g&#x2e;, by altering the <a href="qpainter.html">QPainter</a> state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</p>
<p>It is recommended that the styles do not alter the proposed size of widgets with the <a href="qstyle.html#sizeFromContents">QStyle::sizeFromContents</a>() function but let the <a href="qcommonstyle.html">QCommonStyle</a> implementation handle it. If changes need to be made, you should try to keep them small; application development may be difficult if the layout of widgets looks considerably different in the various styles.</p>
<p>We recommend using the <a href="qpainter.html">QPainter</a> directly for drawing, i.e&#x2e;, not use pixmaps or images. This makes it easier for the style conform to the palette (although you can set your own color table on a <a href="qimage.html">QImage</a> with <a href="qimage.html#setColorTable">setColorTable()</a>).</p>
<p>It is, naturally, possible to draw elements without using the style to draw the sub elements as intended by Qt. This is discouraged as custom widgets may depend on these sub elements to be implemented correctly. The widget walkthrough shows how Qt uses the sub elements.</p>
<a name="java-style"></a>
<h3>Java Style</h3>
<p>We have implemented a style that resembles the Java default look and feel (previously known as Metal). We have done this as it is relatively simple to implement and we wanted to build a style for this overview document. To keep it simple and not to extensive, we have simplified the style somewhat, but Qt is perfectly able to make an exact copy of the style. However, there are no concrete plans to implement the style as a part of Qt.</p>
<p>In this section we will have a look at some implementation issues. Finally, we will see a complete example on the styling of a Java widget. We will continue to use the java style throughout the document for examples and widget images. The implementation itself is somewhat involved, and it is not intended that you should read through it.</p>
<a name="design-and-implementation"></a>
<h4>Design and Implementation</h4>
<p>The first step in designing the style was to select the base class. We chose to subclass <a href="qwindowsstyle.html">QWindowsStyle</a>. This class implements most of the functionality we need other than performing the actual drawing. Also, windows and java share layout of sub controls for several of the complex controls (which reduces the amount of code required considerably).</p>
<p>The style is implemented in one class. We have done this because we find it convenient to keep all code in one file. Also, it is an advantage with regards to optimization as we instantiate less objects. We also keep the number of functions at a minimum by using switches to identify which element to draw in the functions. This results in large functions, but since we divide the code for each element in the switches, the code should still be easy to read.</p>
<a name="limitations-and-differences-from-java"></a>
<h4>Limitations and Differences from Java</h4>
<p>We have not fully implemented every element in the Java style. This way, we have reduced the amount and complexity of the code. In general, the style was intended as a practical example for this style overview document, and not to be a part of Qt itself.</p>
<p>Not all widgets have every state implemented. This goes for states that are common, e.g&#x2e;, State_Disabled. Each state is, however, implemented for at least one widget.</p>
<p>We have only implemented ticks below the slider. Flat push buttons are also left out. We do not handle the case where the title bars and dock window titles grows to small for their contents, but simply draw sub controls over each other.</p>
<p>We have not tried to emulate the Java fonts. Java and Qt use very different font engines, so we don't consider it worth the effort as we only use the style as an example for this overview.</p>
<p>We have hardcoded the colors (we don't use the <a href="qpalette.html">QPalette</a>) for the linear gradients, which are used, for example, for button bevels, tool bars, and check boxes. This is because the Java palette cannot produce these colors. Java does not change these colors based on widget color group or role anyway (they are not dependent on the palette), so it does not present a problem in any case.</p>
<p>It is Qt's widgets that are styled. Some widgets do not exist at all in Java, e.g&#x2e;, <a href="qtoolbox.html">QToolBox</a>. Others contain elements that the Java widgets don't. The tree widget is an example of the latter in which Java's JTree does not have a header.</p>
<p>The style does not handle reverse layouts. We assume that the layout direction is left to right. <a href="qwindowsstyle.html">QWindowsStyle</a> handles reverse widgets; if we implemented reverse layouts, widgets that we change the position of sub elements, or handle text alignment in labels our selves would need to be updated.</p>
<a name="styling-java-check-boxes"></a>
<h4>Styling Java Check Boxes</h4>
<p>As an example, we will examine the styling of check boxes in the java style. We describe the complete process and print all code in both the java style and Qt classes involved. In the rest of this document, we will not examine the source code of the individual widgets. Hopefully, this will give you an idea on how to search through the code if you need to check specific implementation details; most widgets follow the same structure as the check boxes. We have edited the <a href="qcommonstyle.html">QCommonStyle</a> code somewhat to remove code that is not directly relevant for check box styling.</p>
<p>We start with a look at how <a href="qcheckbox.html">QCheckBox</a> builds it style option, which is <a href="qstyleoptionbutton.html">QStyleOptionButton</a> for checkboxes:</p>
<pre> opt.init(q);
     if (down)
     opt.state |= QStyle::State_Sunken;
 if (tristate &amp;&amp; noChange)
     opt.state |= QStyle::State_NoChange;
 else
     opt.state |= checked ? QStyle::State_On :
     QStyle::State_Off;
 if (q-&gt;testAttribute(Qt::WA_Hover) &amp;&amp;  q-&gt;underMouse()) {
     if (hovering)
     opt.state |= QStyle::State_MouseOver;
     else
     opt.state &amp;= ~QStyle::State_MouseOver;
 }
 opt.text = text;
 opt.icon = icon;
 opt.iconSize = q-&gt;iconSize();</pre>
<p>First we let <a href="qstyleoption.html">QStyleOption</a> set up the option with the information that is common for all widgets with <tt>init()</tt>. We will look at this shortly.</p>
<p>The down boolean is true when the user press the box down; this is true whether the box is checked or not of the checkbox. The State_NoChange state is set when we have a tristate checkbox and it is partially checked. It has State_On if the box is checked and State_Off if it is unchecked. State_MouseOver is set if the mouse hovers over the checkbox and the widget has attribute <a href="qt.html#WidgetAttribute-enum">Qt::WA_Hover</a> set - you set this in <a href="qstyle.html#polish">QStyle::polish</a>(). In addition, the style option also contains the text, icon, and icon size of the button.</p>
<p><a href="qstyleoption-obsolete.html#init">init()</a> sets up the style option with the attributes that are common for all widgets. We print its implementation here:</p>
<pre>     state = QStyle::State_None;
     if (widget-&gt;isEnabled())
         state |= QStyle::State_Enabled;
     if (widget-&gt;hasFocus())
         state |= QStyle::State_HasFocus;
     if (widget-&gt;window()-&gt;testAttribute(Qt::WA_KeyboardFocusChange))
         state |= QStyle::State_KeyboardFocusChange;
     if (widget-&gt;underMouse())
         state |= QStyle::State_MouseOver;
     if (widget-&gt;window()-&gt;isActiveWindow())
         state |= QStyle::State_Active;
 #ifdef Q_WS_MAC
     extern bool qt_mac_can_clickThrough(const QWidget *w); <span class="comment">//</span>qwidget_mac.cpp
     if (!(state &amp; QStyle::State_Active) &amp;&amp; !qt_mac_can_clickThrough(widget))
         state &amp;= ~QStyle::State_Enabled;
 #endif
 #ifdef QT_KEYPAD_NAVIGATION
     if (widget-&gt;hasEditFocus())
         state |= QStyle::State_HasEditFocus;
 #endif

     direction = widget-&gt;layoutDirection();
     rect = widget-&gt;rect();
     palette = widget-&gt;palette();
     fontMetrics = widget-&gt;fontMetrics();</pre>
<p>The State_Enabled is set when the widget is enabled. When the widget has focus the State_HasFocus flag is set. Equally, the State_Active flag is set when the widget is a child of the active window. The State_MouseOver will only be set if the widget has the WA_HoverEnabled windows flag set. Notice that keypad navigation must be enabled in Qt for the State_HasEditFocus to be included; it is not included by default.</p>
<p>In addition to setting state flags the <a href="qstyleoption.html">QStyleOption</a> contains other information about the widget: <tt>direction</tt> is the layout direction of the layout, <tt>rect</tt> is the bounding rectangle of the widget (the area in which to draw), <tt>palette</tt> is the <a href="qpalette.html">QPalette</a> that should be used for drawing the widget, and <tt>fontMetrics</tt> is the metrics of the font that is used by the widget.</p>
<p>We give an image of a checkbox and the style option to match it.</p>
<p align="center"><img src="images//checkboxexample.png" alt="A java style checkbox" /></p><p>The above checkbox will have the following state flags in its style option:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State flag</th><th>Set</th></tr></thead>
<tr valign="top" class="odd"><td>State_Sunken</td><td>Yes</td></tr>
<tr valign="top" class="even"><td>State_NoChange</td><td>No</td></tr>
<tr valign="top" class="odd"><td>State_On</td><td>Yes</td></tr>
<tr valign="top" class="even"><td>State_Off</td><td>No</td></tr>
<tr valign="top" class="odd"><td>State_MouseOver</td><td>Yes</td></tr>
<tr valign="top" class="even"><td>State_Enabled</td><td>Yes</td></tr>
<tr valign="top" class="odd"><td>State_HasFocus</td><td>Yes</td></tr>
<tr valign="top" class="even"><td>State_KeyboardFocusChange</td><td>No</td></tr>
<tr valign="top" class="odd"><td>State_Active</td><td>Yes</td></tr>
</table></p>
<p>The <a href="qcheckbox.html">QCheckBox</a> paints itself in <a href="qwidget.html#paintEvent">QWidget::paintEvent</a>() with style option <tt>opt</tt> and <a href="qstylepainter.html">QStylePainter</a> <tt>p</tt>. The <a href="qstylepainter.html">QStylePainter</a> class is a convenience class to draw style elements. Most notably, it wraps the methods in <a href="qstyle.html">QStyle</a> used for painting. The <a href="qcheckbox.html">QCheckBox</a> draws itself as follows:</p>
<pre>     QStylePainter p(this);
     QStyleOptionButton opt = d-&gt;getStyleOption();
     p.drawControl(QStyle::CE_CheckBox, opt);</pre>
<p><a href="qcommonstyle.html">QCommonStyle</a> handles the CE_CheckBox element. The <a href="qcheckbox.html">QCheckBox</a> has two sub elements: SE_CheckBoxIndicator (the checked indicator) and SE_CheckBoxContents (the contents, which is used for the checkbox label). <a href="qcommonstyle.html">QCommonStyle</a> also implements these sub element bounding rectangles. We have a look at the <a href="qcommonstyle.html">QCommonStyle</a> code:</p>
<pre>             QStyleOptionButton subopt = *btn;
             subopt.rect = subElementRect(SE_CheckBoxIndicator, btn, widget);
             drawPrimitive(PE_IndicatorCheckBox, &amp;subopt, p, widget);
             subopt.rect = subElementRect(SE_CheckBoxContents, btn, widget);
             drawControl(CE_CheckBoxLabel, &amp;subopt, p, widget);

             if (btn-&gt;state &amp; State_HasFocus) {
                 QStyleOptionFocusRect fropt;
                 fropt.QStyleOption::operator=(*btn);
                 fropt.rect = subElementRect(SE_CheckBoxFocusRect, btn, widget);
                 drawPrimitive(PE_FrameFocusRect, &amp;fropt, p, widget);
             }</pre>
<p>As can be seen from the code extract, the common style gets the bounding rectangles of the two sub elements of CE_CheckBox, and then draws them. If the checkbox has focus, the focus frame is also drawn.</p>
<p>The java style draws CE_CheckBoxIndicator, while <a href="qcommonstyle.html">QCommonStyle</a> handles CE_CheckboxLabel. We will examine each implementation and start with CE_CheckBoxLabel:</p>
<pre>         const QStyleOptionButton *btn = qstyleoption_cast&lt;const QStyleOptionButton *&gt;(opt)
             uint alignment = visualAlignment(btn-&gt;direction, Qt::AlignLeft | Qt::AlignVCenter);

             if (!styleHint(SH_UnderlineShortcut, btn, widget))
                 alignment |= Qt::TextHideMnemonic;
             QPixmap pix;
             QRect textRect = btn-&gt;rect;
             if (!btn-&gt;icon.isNull()) {
                 pix = btn-&gt;icon.pixmap(btn-&gt;iconSize, btn-&gt;state &amp; State_Enabled ? QIcon::Normal : QIcon::Disabled);
                 drawItemPixmap(p, btn-&gt;rect, alignment, pix);
                 if (btn-&gt;direction == Qt::RightToLeft)
                     textRect.setRight(textRect.right() - btn-&gt;iconSize.width() - 4);
                 else
                     textRect.setLeft(textRect.left() + btn-&gt;iconSize.width() + 4);
             }
             if (!btn-&gt;text.isEmpty()){
                 drawItemText(p, textRect, alignment | Qt::TextShowMnemonic,
                     btn-&gt;palette, btn-&gt;state &amp; State_Enabled, btn-&gt;text, QPalette::WindowText);
             }</pre>
<p><a href="qstyle.html#visualAlignment">visualAlignment()</a> adjusts the alignment of text according to the layout direction. We then draw an icon if it exists, and adjust the space left for the text. <a href="qstyle.html#drawItemText">drawItemText()</a> draws the text taking alignment, layout direction, and the mnemonic into account. It also uses the palette to draw the text in the right color.</p>
<p>The drawing of labels often get somewhat involved. Luckily, it can usually be handled by the base class. The java style implements its own push button label since Java-contrary to windows-center button contents also when the button has an icon. You can examine that implementation if you need an example of reimplementing label drawing.</p>
<p>We take a look at the java implementation of CE_CheckBoxIndicator in <tt>drawControl()</tt>:</p>
<pre>         case PE_IndicatorCheckBox: {
             painter-&gt;save();
             drawButtonBackground(option, painter, true);

             if (option-&gt;state &amp; State_Enabled &amp;&amp;
                 option-&gt;state &amp; State_MouseOver &amp;&amp;
                 !(option-&gt;state &amp; State_Sunken)) {
                 painter-&gt;setPen(option-&gt;palette.color(QPalette::Button));
                 QRect rect = option-&gt;rect.adjusted(1, 1, -2, -2);
                 painter-&gt;drawRect(rect);
                 rect = rect.adjusted(1, 1, -1, -1);
                 painter-&gt;drawRect(rect);
             }

             if (option-&gt;state &amp; State_On) {
                 QImage image(&quot;:/images/checkboxchecked.png&quot;);
                 painter-&gt;drawImage(option-&gt;rect.topLeft(), image);
             }
             painter-&gt;restore();
             break;</pre>
<p>We first save the state of the painter. This is not always necessary but in this case the <a href="qwindowsstyle.html">QWindowsStyle</a> needs the painter in the same state as it was when PE_IndicatorCheckBox was called (We could also set the state with function calls, of course). We then use <tt>drawButtonBackground()</tt> to draw the background of the check box indicator. This is a helper function that draws the background and also the frame of push buttons and check boxes. We take a look at that function below. We then check if the mouse is hovering over the checkbox. If it is, we draw the frame java checkboxes have when the box is not pressed down and the mouse is over it. You may note that java does not handle tristate boxes, so we have not implemented it.</p>
<p>Here we use a png image for our indicator. We could also check here if the widget is disabled. We would then have to use another image with the indicator in the disabled color.</p>
<pre> void JavaStyle::drawButtonBackground(const QStyleOption *option,
                                      QPainter *painter, bool isCheckbox) const
 {
     QBrush buttonBrush = option-&gt;palette.button();
     bool sunken = option-&gt;state &amp; State_Sunken;
     bool disabled = !(option-&gt;state &amp; State_Enabled);
     bool on = option-&gt;state &amp; State_On;

     if (!sunken &amp;&amp; !disabled &amp;&amp; (!on || isCheckbox))
         buttonBrush = gradientBrush(option-&gt;rect);

         painter-&gt;fillRect(option-&gt;rect, buttonBrush);

         QRect rect = option-&gt;rect.adjusted(0, 0, -1, -1);

         if (disabled)
             painter-&gt;setPen(option-&gt;palette.color(QPalette::Disabled,
                                                   QPalette::WindowText));
         else
             painter-&gt;setPen(option-&gt;palette.color(QPalette::Mid));

         painter-&gt;drawRect(rect);

         if (sunken &amp;&amp; !disabled) {
             drawSunkenButtonShadow(painter, rect,
                    option-&gt;palette.color(QPalette::Mid),
                    option-&gt;direction == Qt::RightToLeft);
     }
 }</pre>
<p>We have seen how check boxes are styled in the java style from the widget gets a paint request to the style is finished painting. To learn in detail how each widget is painted, you need to go through the code step-by-step as we have done here. However, it is usually enough to know which style elements the widgets draw. The widget builds a style option and calls on the style one or more times to draw the style elements of which it consists. Usually, it is also sufficient to know the states a widget can be in and the other contents of the style option, i.e&#x2e;, what we list in the next section.</p>
<a name="widget-walkthrough"></a>
<h3>Widget Walkthrough</h3>
<p>In this section, we will examine how most of Qt's widgets are styled. Hopefully, this will save you some time and effort while developing your own styles and widgets. You will not find information here that is not attainable elsewhere (i.e&#x2e;, by examining the source code or the class descriptions for the style related classes).</p>
<p>We mostly use java style widgets as examples. The java style does not draw every element in the element trees. This is because they are not visible for that widget in the java style. We still make sure that all elements are implemented in a way that conforms with the java style as custom widgets might need them (this does not exclude leaving implementations to <a href="qwindowsstyle.html">QWindowsStyle</a> though).</p>
<p>The following is given for each widget:</p>
<ul>
<li>A table with the members (variables, etc.) of its style option.</li>
<li>A table over the state flags (<a href="qstyle.html#StateFlag-enum">QStyle::StateFlag</a>) that can be set on the widget and when the states are set.</li>
<li>Its element tree (see section <a href="#the-style-elements">The Style Elements</a>).</li>
<li>An image of the widget in which the elements are outlined.</li>
</ul>
<p>The element tree contains the primitive, control, and complex style elements. By doing a top-down traversal of the element tree, you get the sequence in which the elements should be drawn. In the nodes, we have written the sub element rectangles, sub control elements, and pixel metrics that should be considered when drawing the element of the node.</p>
<p>Our approach on styling center on the drawing of the widgets. The calculations of sub elements rectangles, sub controls, and pixel metrics used <b>during</b> drawing is only listed as contents in the element trees. Note that there are rectangles and pixel metrics that are only used by widgets. This leaves these calculations untreated in the walkthrough. For instance, the <a href="qstyle.html#subControlRect">subControlRect()</a> and <a href="qstyle.html#sizeFromContents">sizeFromContents()</a> functions often call <a href="qstyle.html#subElementRect">subElementRect()</a> to calculate their bounding rectangles. We could draw trees for this as well. However, how these calculations are done is completely up to the individual styles, and they do not have to follow a specific structure (Qt does not impose a specific structure). You should still make sure that you use the appropriate pixel metrics, though. To limit the size of the document, we have therefore chosen not to include trees or describe the calculations made by the Java (or any other) style.</p>
<p>You may be confused about how the different pixel metrics, sub element rectangles, and sub control rectangles should be used when examining the trees. If you are in doubt after reading the <a href="qstyle.html">QStyle</a> enum descriptions, we suggest that you examine the <a href="qcommonstyle.html">QCommonStyle</a> and <a href="qwindowsstyle.html">QWindowsStyle</a> implementations.</p>
<p>Some of the bounding rectangles that we outline in the widget images are equal. Reasons for this are that some elements draw backgrounds while others draw frames and labels. If in doubt, check the description of each element in <a href="qstyle.html">QStyle</a>. Also, some elements are there to layout, i.e&#x2e;, decide where to draw, other elements.</p>
<a name="common-widget-properties"></a>
<h4>Common Widget Properties</h4>
<p>Some states and variables are common for all widgets. These are set with <a href="qstyleoption-obsolete.html#init">QStyleOption::init</a>(). Not all elements use this function; it is the widgets that create the style options, and for some elements the information from <a href="qstyleoption-obsolete.html#init">init()</a> is not necessary.</p>
<p>A table with the common states follows:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>State Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Enabled</td><td>Set if the widget is not disabled (see <a href="qwidget.html#enabled-prop">QWidget::setEnabled</a>())</td></tr>
<tr valign="top" class="even"><td>State_Focus</td><td>Set if the widget has focus (see <a href="qwidget.html#focus-prop">QWidget::hasFocus</a>())</td></tr>
<tr valign="top" class="odd"><td>State_KeyobordFocusChange</td><td>Set when the user changes focus with the keyboard (see <a href="qt.html#WidgetAttribute-enum">Qt::WA_KeyboardFocusChange</a>)</td></tr>
<tr valign="top" class="even"><td>State_MouseOver</td><td>Set if the mouse cursor is over the widget</td></tr>
<tr valign="top" class="odd"><td>State_Active</td><td>Set if the widget is a child of the active window.</td></tr>
<tr valign="top" class="even"><td>State_HasEditFocus</td><td>Set if the widget has the edit focus</td></tr>
</table></p>
<p>The other common members for widgets are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>rect</td><td>The bounding rectangle of the element to draw. This is set to the widget bounding rectangle (<a href="qwidget.html#rect-prop">QWidget::rect</a>()).</td></tr>
<tr valign="top" class="even"><td>direction</td><td>The layout direction; a value of the <a href="qt.html#LayoutDirection-enum">Qt::LayoutDirection</a> enum.</td></tr>
<tr valign="top" class="odd"><td>palette</td><td>The <a href="qpalette.html">QPalette</a> to use when drawing the element. This is set to the widgets palette (<a href="qwidget.html#palette-prop">QWidget::palette</a>()).</td></tr>
<tr valign="top" class="even"><td>fontMetrics</td><td>The <a href="qfontmetrics.html">QFontMetrics</a> to use when drawing text on the widget.</td></tr>
</table></p>
<p>The complex style options (classes that inherit <a href="qstyleoptioncomplex.html">QStyleOptionComplex</a>) used for complex style elements share two variables: <a href="qstyleoptioncomplex.html#subControls-var">subControls</a> and <a href="qstyleoptioncomplex.html#activeSubControls-var">activeSubControls</a>. Both variables are an OR'ed combination of <a href="qstyle.html#SubControl-enum">QStyle::SubControl</a> enum values. They indicate which sub controls the complex control consists of and which of these controls are currently active.</p>
<p>As mentioned, the style calculates the size of the widgets contents, which the widgets calculate their size hints from. In addition, complex controls also use the style to test which sub-controls the mouse is over.</p>
<a name="widget-reference"></a>
<h4>Widget Reference</h4>
<p>Without further delay, we present the widget walkthrough; each widget has its own sub-section.</p>
<a name="push-buttons"></a>
<h5>Push Buttons</h5>
<p>The style structure for push buttons is shown below. By doing a top-down traversal of the tree, you get the sequence in which the elements should be drawn.</p>
<p align="center"><img src="images//pushbutton.png" alt="The style structure for push buttons" /></p><p>The layout of the buttons, with regard element bounds, varies from style to style. This makes it difficult to show conceptual images of this. Also, elements may - even be intended to - have the same bounds; the PE_PushButtonBevel, for instance, is used in <a href="qcommonstyle.html">QCommonStyle</a> to draw the elements that contains it: PE_FrameDefaultButton, PE_FrameButtonBevel, and PE_PanelButtonCommand, all of which have the same bounds in common and windows style. PE_PushButtonBevel is also responsible for drawing the menu indicator (<a href="qcommonstyle.html">QCommonStyle</a> draws PE_IndicatorArrowDown).</p>
<p>An image of a push button in the java style that show the bounding rectangles of the elements is given below. Colors are used to separate the bounding rectangles in the image; they do not fill any other purpose. This is also true for similar images for the other widgets.</p>
<p align="center"><img src="images//button.png" /></p><p>The java style, as well as all other styles implemented in Qt, does not use PE_FrameButtonBevel. It is usual that a button with a PE_DefaultFrame adjusts the PE_PanelButtonCommand's rectangle by PM_ButtonDefaultIndicator. The CE_PushButtonLabel is found by adjusting the rect by PM_DefaultFrameWidth.</p>
<p>We will now examine the style option for push buttons - <a href="qstyleoptionbutton.html">QStyleOptionButton</a>. A table for the states that <a href="qpushbutton.html">QPushButton</a> can set on the style option follows:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>State Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Sunken</td><td>Button is down or menu is pressed shown</td></tr>
<tr valign="top" class="even"><td>State_On</td><td>Button is checked</td></tr>
<tr valign="top" class="odd"><td>State_Raised</td><td>Button is not flat and not pressed down</td></tr>
</table></p>
<p>Other members of <a href="qstyleoptionbutton.html">QStyleOptionButton</a> is:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>features</td><td>Flags of the <a href="qstyleoptionbutton.html#ButtonFeature-enum">QStyleOptionButton::ButtonFeatures</a> enum, which describes various button properties (see enum)</td></tr>
<tr valign="top" class="even"><td>icon</td><td>The buttons <a href="qicon.html">QIcon</a> (if any)</td></tr>
<tr valign="top" class="odd"><td>iconSize</td><td>The <a href="qsize.html">QSize</a> of the icon</td></tr>
<tr valign="top" class="even"><td>text</td><td>a <a href="qstring.html">QString</a> with the buttons text</td></tr>
</table></p>
<a name="check-and-radio-buttons"></a>
<h5>Check and Radio Buttons</h5>
<p>The structures for radio and check buttons are identical. We show the structure using <a href="qcheckbox.html">QCheckBox</a> element and pixel metric names:</p>
<p align="center"><img src="images//checkbox.png" /></p><p><a href="qstyleoptionbutton.html">QStyleOptionButton</a> is used as the style option for both check and radio buttons. We first give a table of the states that can be set in the option:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>State Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_sunken</td><td>The box is pressed down</td></tr>
<tr valign="top" class="even"><td>State_NoChange</td><td>The box is partially checked (for tristate checkboxes.)</td></tr>
<tr valign="top" class="odd"><td>State_On</td><td>The box is checked</td></tr>
<tr valign="top" class="even"><td>State_Off</td><td>The box is unchecked</td></tr>
</table></p>
<p>See <a href="#push-buttons">Push Buttons</a> for a table over other members in the QStyleOptionButtonClass.</p>
<a name="tabs"></a>
<h5>Tabs</h5>
<p>In Qt, <a href="qtabbar.html">QTabBar</a> uses the style to draw its tabs. Tabs exist either in a <a href="qtabwidget.html">QTabWidget</a>, which contains a <a href="qtabbar.html">QTabBar</a>, or as a separate bar. If the bar is not part of a tab widget, it draws its own base.</p>
<p><a href="qtabbar.html">QTabBar</a> lays out the tabs, so the style does not have control over tab placement. However, while laying out its tabs, the bar asks the style for PM_TabBarTabHSpace and PM_TabBarTabVSpace, which is extra width and height over the minimum size of the tab bar tab label (icon and text). The style can also further influence the tab size before it is laid out, as the tab bar asks for CT_TabBarTab. The bounding rectangle of the bar is decided by the tab widget when it is part of the widget (still considering CT_TabBarTab).</p>
<p>The tab bar is responsible for drawing the buttons that appear on the tab bar when all tabs do not fit. Their placement is not controlled by the style, but the buttons are <a href="qtoolbutton.html">QToolButton</a>s and are therefore drawn by the style.</p>
<p>Here is the style structure for <a href="qtabwidget.html">QTabWidget</a> and <a href="qtabbar.html">QTabBar</a>:</p>
<p align="center"><img src="images//tab.png" /></p><p>The dotted lines indicate that the <a href="qtabwidget.html">QTabWidget</a> contains a tab bar, but does not draw it itself, that <a href="qtabbar.html">QTabBar</a> only draws its base line when not part of a tab widget, and that the tab bar keeps two tool buttons that scroll the bar when all tabs do not fit; see <a href="#tool-buttons">Tool Buttons</a> for their element tree. Also note that since the buttons are children of the tab bar, they are drawn after the bar. The tabs bounding rectangles overlap the base by PM_TabBarBaseOverlap.</p>
<p>Here is a tab widget in the java style:</p>
<p align="center"><img src="images//tabwidget.png" /></p><p>In the java style (and also windows), the tab bar shape and label have the same bounding rectangle as CE_TabBarTab. Notice that the tabs overlap with the tab widget frame. The base of the tab bar (if drawn) is the area where the tabs and frame overlap.</p>
<p>The style option for tabs (<a href="qstyleoptiontab.html">QStyleOptionTab</a>) contains the necessary information for drawing tabs. The option contains the position of the tab in the tab bar, the position of the selected tab, the shape of the tab, the text, and icon. After Qt 4.1 the option should be cast to a <a href="qstyleoptiontabv2.html">QStyleOptionTabV2</a>, which also contains the icons size.</p>
<p>As the java style tabs don't overlap, we also present an image of a tab widget in the windows style. Note that if you want the tabs to overlap horizontally, you do that when drawing the tabs in CE_TabBarTabShape; the tabs bounding rectangles will not be altered by the tab bar. The tabs are drawn from left to right in a north tab bar shape, top to bottom in an east tab bar shape, etc. The selected tab is drawn last, so that it is easy to draw it over the other tabs (if it is to be bigger).</p>
<p align="center"><img src="images//windowstabimage.png" /></p><p>A table of the states a tab bar can set on its tabs follows:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>State Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Sunken</td><td>The tab is pressed on with the mouse.</td></tr>
<tr valign="top" class="even"><td>State_Selected</td><td>If it is the current tab.</td></tr>
<tr valign="top" class="odd"><td>State_HasFocus</td><td>The tab bar has focus and the tab is selected</td></tr>
</table></p>
<p>Note that individual tabs may be disabled even if the tab bar is not. The tab will be active if the tab bar is active.</p>
<p>Here follows a table of <a href="qstyleoptiontabv2.html">QStyleOptionTabV2</a>'s members:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>cornerWidgets</td><td>Is flags of the CornerWidget enum, which indicate if and which corner widgets the tab bar has.</td></tr>
<tr valign="top" class="even"><td>icon</td><td>The <a href="qicon.html">QIcon</a> of the tab</td></tr>
<tr valign="top" class="odd"><td>iconSize</td><td>The <a href="qsize.html">QSize</a> of the icon</td></tr>
<tr valign="top" class="even"><td>position</td><td>A TabPosition enum value that indicates the tabs position on the bar relative to the other tabs.</td></tr>
<tr valign="top" class="odd"><td>row</td><td>holds which row the tab is in</td></tr>
<tr valign="top" class="even"><td>selectedPosition</td><td>A value of the SelectedPosition enum that indicates whether the selected tab is adjacent to or is the tab.</td></tr>
<tr valign="top" class="odd"><td>shape</td><td>A value of the <a href="qtabbar.html#Shape-enum">QTabBar::Shape</a> enum indication whether the tab has rounded or triangular corners and the orientation of the tab.</td></tr>
<tr valign="top" class="even"><td>text</td><td>The tab text</td></tr>
</table></p>
<p>The frame for tab widgets use <a href="qstyleoptiontabwidgetframe.html">QStyleOptionTabWidgetFrame</a> as style option. We list its members here. It does not have states set besides the common flags.</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>content</th></tr></thead>
<tr valign="top" class="odd"><td>leftCornerWidgetSize</td><td>The <a href="qsize.html">QSize</a> of the left corner widget (if any).</td></tr>
<tr valign="top" class="even"><td>rightCornerWidgetSize</td><td>The <a href="qsize.html">QSize</a> of the right corner widget (if any).</td></tr>
<tr valign="top" class="odd"><td>lineWidth</td><td>holds the line with for drawing the panel.</td></tr>
<tr valign="top" class="even"><td>midLineWith</td><td>this value is currently always 0.</td></tr>
<tr valign="top" class="odd"><td>shape</td><td>The shape of the tabs on the tab bar.</td></tr>
<tr valign="top" class="even"><td>tabBarSize</td><td>The <a href="qsize.html">QSize</a> of the tab bar.</td></tr>
</table></p>
<a name="scroll-bars"></a>
<h5>Scroll Bars</h5>
<p>Here is the style structure for scrollBars:</p>
<p align="center"><img src="images//scrollbar.png" /></p><p><a href="qscrollbar.html">QScrollBar</a> simply creates its style option and then draws CC_ScrollBar. Some styles draw the background of add page and sub page with PE_PanelButtonBevel and also use indicator arrows to draw the arrows in the nest and previous line indicators; we have not included these in the tree as their use is up to the individual style. The style's PM_MaximumDragDistance is the maximum distance in pixels the mouse can move from the bounds of the scroll bar and still move the handle.</p>
<p>Here is an image of a scrollbar in the java style:</p>
<p align="center"><img src="images//scrollbarimage.png" /></p><p>You may notice that the scrollbar is slightly different from Java's as it has two line up indicators. We have done this to show how that you can have two separate bounding rectangles for a single sub control. The scroll bar is an example of a widget that is entirely implemented by the java style - neither <a href="qwindowsstyle.html">QWindowsStyle</a> nor <a href="qcommonstyle.html">QCommonStyle</a> are involved in the drawing.</p>
<p>We have a look at the different states a scroll bar can set on the style option:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>State Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Horizontal</td><td>The scroll bar is horizontal</td></tr>
</table></p>
<p>The style option of <a href="qscrollbar.html">QScrollBar</a> is <a href="qstyleoptionslider.html">QStyleOptionSlider</a>. Its members are listed in the following table. The option is used by all <a href="qabstractslider.html">QAbstractSlider</a>s; we only describe the members relevant for scroll bars here.</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>maximum</td><td>the maximum value of the scroll bar</td></tr>
<tr valign="top" class="even"><td>minimum</td><td>the minimum value of the scroll bar</td></tr>
<tr valign="top" class="odd"><td>notchTarget</td><td>the number of pixels between notches</td></tr>
<tr valign="top" class="even"><td>orientation</td><td>a value of the <a href="qt.html#Orientation-enum">Qt::Orientation</a> enum that specifies whether the scroll bar is vertical or horizontal</td></tr>
<tr valign="top" class="odd"><td>pageStep</td><td>the number to increase or decrease the sliders value (relative to the size of the slider and its value range) on page steps.</td></tr>
<tr valign="top" class="even"><td>singleStep</td><td>the number to increase or decrease the sliders value on single (or line) steps</td></tr>
<tr valign="top" class="odd"><td>sliderValue</td><td>The value of the slider</td></tr>
<tr valign="top" class="even"><td>sliderPosition</td><td>the position of the slider handle. This is the same as <tt>sliderValue</tt> if the scroll bar is <a href="qabstractslider.html#tracking-prop">QAbstractSlider::tracking</a>. If not, the scroll bar does not update its value before the mouse releases the handle.</td></tr>
<tr valign="top" class="odd"><td>upsideDown</td><td>holds the direction in which the scroll bar increases its value. This is used instead of <a href="qstyleoption.html#direction-var">QStyleOption::direction</a> for all abstract sliders.</td></tr>
</table></p>
<a name="sliders"></a>
<h5>Sliders</h5>
<p>When calculating the sliders size hint, PM_SliderTickness and PM_SliderLength is queried from the style. As with scroll bars, the <a href="qslider.html">QSlider</a> only lets the user move the handle if the mouse is within PM_MaximumDragDistance from the slider bounds. When it draws itself it creates the style option and calls <tt>drawComplexControl()</tt> with CC_Slider:</p>
<p align="center"><img src="images//slider.png" /></p><p>We also show a picture of a slider in the java style. We show the bounding rectangles of the sub elements as all drawing is done in CC_Slider.</p>
<p align="center"><img src="images//sliderimage.png" /></p><p><a href="qslider.html">QSlider</a> uses <a href="qstyleoptionslider.html">QStyleOptionSlider</a> as all <a href="qabstractslider.html">QAbstractSlider</a>s do. We present a table with the members that affect <a href="qslider.html">QSlider</a>:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>maximum</td><td>the maximum value of the slider</td></tr>
<tr valign="top" class="even"><td>minimum</td><td>the minimum value of the slider</td></tr>
<tr valign="top" class="odd"><td>notchTarget</td><td>this is the number of pixels between each notch</td></tr>
<tr valign="top" class="even"><td>orientation</td><td>a <a href="qt.html#Orientation-enum">Qt::Orientation</a> enum value that gives whether the slider is vertical or horizontal.</td></tr>
<tr valign="top" class="odd"><td>pageStep</td><td>a number in slider value to increase or decrease for page steps</td></tr>
<tr valign="top" class="even"><td>singleStep</td><td>the number to increase or decrease the sliders value on single (or line) steps.</td></tr>
<tr valign="top" class="odd"><td>sliderValue</td><td>the value of the slider.</td></tr>
<tr valign="top" class="even"><td>sliderPosition</td><td>the position of the slider given as a slider value. This will be equal to the <tt>sliderValue</tt> if the slider is <a href="qabstractslider.html#tracking-prop">tracking</a>; if not, the sliders value will not change until the handle is released with the mouse.</td></tr>
<tr valign="top" class="odd"><td>upsideDown</td><td>this member is used instead of <a href="qstyleoption.html#direction-var">QStyleOption::direction</a> for all abstract sliders.</td></tr>
</table></p>
<p>You should note that the slider does not use direction for reverse layouts; it uses <tt>upsideDown</tt>.</p>
<a name="spin-boxes"></a>
<h5>Spin Boxes</h5>
<p>When <a href="qspinbox.html">QSpinBox</a> paints itself it creates a <a href="qstyleoptionspinbox.html">QStyleOptionSpinBox</a> and asks the style to draw CC_SpinBox. The edit field is a line edit that is a child of the spin box. The dimensions of the field is calculated by the style with SC_SpinBoxEditField.</p>
<p>Here follows the style tree for spin boxes. It is not required that a style uses the button panel primitive to paint the indicator backgrounds. You can see an image below the tree showing the sub elements in <a href="qspinbox.html">QSpinBox</a> in the java style.</p>
<p align="center"><img src="images//spinbox.png" /></p><p align="center"><img src="images//spinboximage.png" /></p><p>The <a href="qstyleoptionspinbox.html">QStyleOptionSpinBox</a>, which is the style option for spin boxes. It can set the following states on the spin box.:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>State Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Sunken</td><td>Is set if one of the sub controls CC_SpinUp or CC_SpinDown is pressed on with the mouse.</td></tr>
</table></p>
<p>The rest of the members in the spin boxes style options are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Property</th><th>Function</th></tr></thead>
<tr valign="top" class="odd"><td>frame</td><td>boolean that is true if the spin box is to draw a frame.</td></tr>
<tr valign="top" class="even"><td>buttonSymbols</td><td>Value of the ButtonSymbols enum that decides the symbol on the up/down buttons.</td></tr>
<tr valign="top" class="odd"><td>stepEnabled</td><td>A value of the StepEnabled indication which of the spin box buttons are pressed down.</td></tr>
</table></p>
<a name="title-bar"></a>
<h5>Title Bar</h5>
<p>The title bar complex control, CC_TitleBar, is used to draw the title bars of internal windows in <a href="qmdiarea.html">QMdiArea</a>. It typically consists of a window title and close, minimize, system menu, and maximize buttons. Some styles also provide buttons for shading the window, and a button for context sensitive help.</p>
<p>The bar is drawn in CC_TitleBar without using any sub elements. How the individual styles draw their buttons is individual, but there are standard pixmaps for the buttons that the style should provide.</p>
<p align="center"><img src="images//titlebar.png" /></p><p>In an image over a title bar in the java style, we show the bounding rectangles of the sub elements supported by the java style (all of which are drawn with standard pixmaps). It is usual to draw the button backgrounds using PE_PanelButtonTool, but it's no rule.</p>
<p align="center"><img src="images//titlebarimage.png" /></p><p>The style option for title bars is <a href="qstyleoptiontitlebar.html">QStyleOptionTitleBar</a>. It's members are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>icon</td><td>The title bars icon</td></tr>
<tr valign="top" class="even"><td>text</td><td>the text for the title bar's label</td></tr>
<tr valign="top" class="odd"><td>windowFlags</td><td>flags of the Qt::WindowFlag enum. The window flags used by <a href="qmdiarea.html">QMdiArea</a> for window management.</td></tr>
<tr valign="top" class="even"><td>titleBarState</td><td>this is the <a href="qwidget.html#windowState">QWidget::windowState</a>() of the window that contains the title bar.</td></tr>
</table></p>
<a name="combo-box"></a>
<h5>Combo Box</h5>
<p>A <a href="qcombobox.html">QComboBox</a> uses the style to draw the button and label of non-editable boxes with CC_ComboBox and CE_ComboBoxLabel.</p>
<p>The list that pops up when the user clicks on the combo box is drawn by a <a href="model-view-delegate.html">delegate</a>, which we do not cover in this overview. You can, however, use the style to control the list's size and position with the sub element SC_ComboBoxListBoxPopup. The style also decides where the edit field for editable boxes should be with SC_ComboBoxEditField; the field itself is a <a href="qlineedit.html">QLineEdit</a> that is a child of the combo box.</p>
<p align="center"><img src="images//combobox.png" /></p><p>We show an image over a java style combo box in which we have outlined its sub elements and sub element rectangles:</p>
<p align="center"><img src="images//comboboximage.png" /></p><p>Java combo boxes do not use the focus rect; it changes its background color when it has focus. The SC_ComboBoxEdit field is used both by <a href="qcombobox.html">QComboBox</a> to calculate the size of the edit field and the style for calculating the size of the combo box label.</p>
<p>The style option for combo boxes is <a href="qstyleoptioncombobox.html">QStyleOptionComboBox</a>. It can set the following states:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Selected</td><td>The box is not editable and has focus</td></tr>
<tr valign="top" class="even"><td>State_Sunken</td><td>SC_ComboBoxArrow is active</td></tr>
<tr valign="top" class="odd"><td>State_on</td><td>The container (list) of the box is visible</td></tr>
</table></p>
<p>The style options other members are:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>currentIcon</td><td>the icon of the current (selected) item of the combo box.</td></tr>
<tr valign="top" class="even"><td>currentText</td><td>the text of the current item in the box.</td></tr>
<tr valign="top" class="odd"><td>editable</td><td>holds whether the combo box is editable or not</td></tr>
<tr valign="top" class="even"><td>frame</td><td>holds whether the combo box has a frame or not</td></tr>
<tr valign="top" class="odd"><td>iconSize</td><td>the size of the current items icon.</td></tr>
<tr valign="top" class="even"><td>popupRect</td><td>the bounding rectangle of the combo box's popup list.</td></tr>
</table></p>
<a name="group-boxes"></a>
<h5>Group Boxes</h5>
<p>When calculating the size hint, <a href="qgroupbox.html">QGroupBox</a> fetches three pixel metrics from the style: PM_IndicatorWidth, PM_CheckBoxLabelSpacing, and PM_IndicatorHeight. <a href="qgroupbox.html">QGroupBox</a> has the following style element tree:</p>
<p align="center"><img src="images//groupbox.png" /></p><p>Qt does not impose restrictions on how the check box is drawn; the java style draws it with CE_IndicatorCheckBox. See <a href="#check-and-radio-buttons">Check and Radio Buttons</a> for the complete tree.</p>
<p>We also give an image of the widget with the sub controls and sub control rectangles drawn:</p>
<p align="center"><img src="images//groupboximage.png" /></p><p>The style option for group boxes are <a href="qstyleoptiongroupbox.html">QStyleOptionGroupBox</a>. The following states can be set on it:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_On</td><td>The check box is checked</td></tr>
<tr valign="top" class="even"><td>State_Sunken</td><td>The checkbox is pressed down</td></tr>
<tr valign="top" class="odd"><td>State_Off</td><td>The check box is unchecked (or there is no check box)</td></tr>
</table></p>
<p>The remaining members of <a href="qstyleoptiongroupbox.html">QStyleOptionGroupBox</a> are:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>features</td><td>flags of the <a href="qstyleoptionframev2.html#FrameFeature-enum">QStyleOptionFrameV2::FrameFeatures</a> enum describing the frame of the group box.</td></tr>
<tr valign="top" class="even"><td>lineWidth</td><td>the line width with which to draw the panel. This is always 1.</td></tr>
<tr valign="top" class="odd"><td>text</td><td>the text of the group box.</td></tr>
<tr valign="top" class="even"><td>textAlignment</td><td>the alignment of the group box title</td></tr>
<tr valign="top" class="odd"><td>textColor</td><td>the <a href="qcolor.html">QColor</a> of the text</td></tr>
</table></p>
<a name="splitters"></a>
<h5>Splitters</h5>
<p>As the structure of splitters are simple and do not contain any sub elements, we do not include image of splitters. CE_Splitter does not use any other elements or metrics.</p>
<p>For its style option, Splitters uses the base class <a href="qstyleoption.html">QStyleOption</a>. It can set the following state flags on it:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Horizontal</td><td>Set if it is a horizontal splitter</td></tr>
</table></p>
<p><a href="qsplitter.html">QSplitter</a> does not use <a href="qstyleoption-obsolete.html#init">init()</a> to set up its option; it sets the State_MouseOver and State_Disabled flags itself.</p>
<a name="progress-bar"></a>
<h5>Progress Bar</h5>
<p>The CE_ProgressBar element is used by <a href="qprogressbar.html">QProgressBar</a>, and it is the only element used by this widget. We start with looking at the style structure:</p>
<p align="center"><img src="images//progressbar.png" /></p><p>Here is a progress bar in the windows style (the java style bounding rectangles are equal):</p>
<p align="center"><img src="images//progressbarimage.png" /></p><p>The style option for <a href="qprogressbar.html">QProgressBar</a> is <a href="qstyleoptionprogressbarv2.html">QStyleOptionProgressBarV2</a>. The bar does not set any state flags, but the other members of the option are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>minimum</td><td>The minimum value of the bar</td></tr>
<tr valign="top" class="even"><td>maximum</td><td>The maximum value of the bar</td></tr>
<tr valign="top" class="odd"><td>progress</td><td>The current value of the bar</td></tr>
<tr valign="top" class="even"><td>textAlignment</td><td>How the text is aligned in the label</td></tr>
<tr valign="top" class="odd"><td>textVisible</td><td>Whether the label is drawn</td></tr>
<tr valign="top" class="even"><td>text</td><td>The label text</td></tr>
<tr valign="top" class="odd"><td>orientation</td><td>Progress bars can be vertical or horizontal</td></tr>
<tr valign="top" class="even"><td>invertedAppearance</td><td>The progress is inverted (i.e&#x2e;, right to left in a horizontal bar)</td></tr>
<tr valign="top" class="odd"><td>bottomToTop</td><td>Boolean that if true, turns the label of vertical progress bars 90 degrees.</td></tr>
</table></p>
<a name="tool-buttons"></a>
<h5>Tool Buttons</h5>
<p>Tool buttons exist either independently or as part of tool bars. They are drawn equally either way. The <a href="qtoolbutton.html">QToolButton</a> draws only one style element: CC_ToolButton.</p>
<p>As you must be used to by now (at least if you have read this document sequentially), we have a tree of the widget's style structure:</p>
<p align="center"><img src="images//toolbutton.png" /></p><p>Note that PE_FrameButtonTool and PE_IndicatorArrowDown are included in the tree as the java style draws them, but they can safely be omitted if you prefer it. The structure may also be different. <a href="qwindowsstyle.html">QWindowsStyle</a>, for instance, draws both PE_IndicatorButtonDropDown and PE_IndicatorArrowDown in CE_ToolButton.</p>
<p>We also have an image of a tool button where we have outlined the sub element bounding rectangles and sub controls.</p>
<p align="center"><img src="images//toolbuttonimage.png" /></p><p>Here is the states table for tool buttons:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_AutoRise</td><td>the tool button has the autoRise property set</td></tr>
<tr valign="top" class="even"><td>State_raised</td><td>the button is not sunken (i.e&#x2e;, by being checked or pressed on with the mouse).</td></tr>
<tr valign="top" class="odd"><td>State_Sunken</td><td>the button is down</td></tr>
<tr valign="top" class="even"><td>State_On</td><td>the button is checkable and checked.</td></tr>
</table></p>
<p><a href="qstyleoptiontoolbutton.html">QStyleOptionToolButton</a> also contains the following members:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>arrowType</td><td>a <a href="qt.html#ArrowType-enum">Qt::ArrowType</a> enum value, which contains the direction of the buttons arrow (if an arrow is to be used in place of an icon)</td></tr>
<tr valign="top" class="even"><td>features</td><td>flags of the QStyleOptionToolButton::ButtonFeature enum describing if the button has an arrow, a menu, and/or has a popup-delay.</td></tr>
<tr valign="top" class="odd"><td>font</td><td>the <a href="qfont.html">QFont</a> of the buttons label</td></tr>
<tr valign="top" class="even"><td>icon</td><td>the <a href="qicon.html">QIcon</a> of the tool button</td></tr>
<tr valign="top" class="odd"><td>iconSize</td><td>the icon size of the button's icon</td></tr>
<tr valign="top" class="even"><td>pos</td><td>the position of the button, as given by <a href="qwidget.html#pos-prop">QWidget::pos</a>()</td></tr>
<tr valign="top" class="odd"><td>text</td><td>the text of the button</td></tr>
<tr valign="top" class="even"><td>toolButtonStyle</td><td>a <a href="qt.html#ToolButtonStyle-enum">Qt::ToolButtonStyle</a> enum value which decides whether the button shows the icon, the text, or both.</td></tr>
</table></p>
<a name="toolbars"></a>
<h5>Toolbars</h5>
<p>Toolbars are part of the <a href="qmainwindow.html">main window framework</a> and cooperates with the <a href="qmainwindow.html">QMainWindow</a> to which it belongs while it builds its style option. A main window has 4 areas that toolbars can be placed in. They are positioned next to the four sides of the window (i.e&#x2e;, north, south, west, and east). Within each area there can be more than one line of toolbars; a line consists of toolbars with equal orientation (vertical or horizontal) placed next to each other.</p>
<p><a href="porting4.html#qtoolbar">QToolbar</a>s in Qt consists of three elements CE_ToolBar, PE_IndicatorToolBarHandle, and PE_IndicatorToolBarSeparator. It is QMainWindowLayout that calculates the bounding rectangles (i.e&#x2e;, position and size of the toolbars and their contents. The main window also uses the <tt>sizeHint()</tt> of the items in the toolbars when calculating the size of the bars.</p>
<p>Here is the element tree for <a href="qtoolbar.html">QToolBar</a>:</p>
<p align="center"><img src="images//toolbar.png" /></p><p>The dotted lines indicate that the <a href="qtoolbar.html">QToolBar</a> keeps an instance of QToolBarLayout and that QToolBarSeparators are kept by QToolBarLayout. When the toolbar is floating (i.e&#x2e;, has its own window) the PE_FrameMenu element is drawn, else <a href="porting4.html#qtoolbar">QToolbar</a> draws CE_ToolBar.</p>
<p>Here is an image of a toolbar in the java style:</p>
<p align="center"><img src="images//toolbarimage.png" /></p><p>QToolBarSaparator uses <a href="qstyleoption.html">QStyleOption</a> for their style option. It sets the State_horizontal flag if the toolbar they live in is horizontal. Other than that, they use <a href="qstyleoption-obsolete.html#init">init()</a>.</p>
<p>The style option for <a href="qtoolbar.html">QToolBar</a> is <a href="qstyleoptiontoolbar.html">QStyleOptionToolBar</a>. The only state flag set (besides the common flags) is State_Horizontal if the bar is horizontal (i.e&#x2e;, in the north or south toolbar area). The member variables of the style option are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>features</td><td>Holds whether the bar is movable in a value of the ToolBarFeature, which is either Movable or None.</td></tr>
<tr valign="top" class="even"><td>lineWidth</td><td>The width of the tool bar frame.</td></tr>
<tr valign="top" class="odd"><td>midLineWidth</td><td>This variable is currently not used and is always 0.</td></tr>
<tr valign="top" class="even"><td>positionOfLine</td><td>The position of the toolbar line within the toolbar area to which it belongs.</td></tr>
<tr valign="top" class="odd"><td>positionWithinLine</td><td>The position of the toolbar within the toolbar line.</td></tr>
<tr valign="top" class="even"><td>toolBarArea</td><td>The toolbar area in which the toolbar lives.</td></tr>
</table></p>
<a name="menus"></a>
<h5>Menus</h5>
<p>Menus in Qt are implemented in <a href="qmenu.html">QMenu</a>. The <a href="qmenu.html">QMenu</a> keeps a list of action, which it draws as menu items. When <a href="qmenu.html">QMenu</a> receives paint events ,it calculates the size of each menu item and draws them individually with CE_MenuItem. (Menu items do not have a separate element for their label (contents), so all drawing is done in CE_MenuItem. The menu also draws the frame of the menu with PE_FrameMenu. It also draws CE_MenuScroller if the style supports scrolling. CE_MenuTearOff is drawn if the menu is to large for its bounding rectangle.</p>
<p>In the style structure tree, we also include <a href="qmenu.html">QMenu</a> as it also does styling related work. The bounding rectangles of menu items are calculated for the menus size hint and when the menu is displayed or resized.</p>
<p align="center"><img src="images//menu.png" /></p><p>The CE_MenuScroller and CE_MenuTearOff elements are handled by <a href="qcommonstyle.html">QCommonStyle</a> and are not shown unless the menu is to large to fit on the screen. PE_FrameMenu is only drawn for popup menus.</p>
<p><a href="qmenu.html">QMenu</a> calculates rectangles based on its actions and calls CE_MenuItem and CE_MenuScroller if the style supports that.</p>
<p>It is also usual to use PE_IndicatorCheckBox (instead of using PE_IndicatorMenuCheckMark) and PE_IndicatorRadioButton for drawing checkable menu items; we have not included them in the style tree as this is optional and varies from style to style.</p>
<p align="center"><img src="images//menuimage.png" /></p><p>The style option for menu items is <a href="qstyleoptionmenuitem.html">QStyleOptionMenuItem</a>. The following tables describe its state flags and other members.</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Selected</td><td>The mouse is over the action and the action is not a separator.</td></tr>
<tr valign="top" class="even"><td>State_Sunken</td><td>The mouse is pressed down on the menu item.</td></tr>
<tr valign="top" class="odd"><td>State_DownArrow</td><td>Set if the menu item is a menu scroller and it scrolls the menu downwards.</td></tr>
</table></p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>checkType</td><td>A value of the <a href="qstyleoptionmenuitem.html#CheckType-enum">CheckType</a> enum, which is either NotCheckable, Exclusive, or NonExclusive.</td></tr>
<tr valign="top" class="even"><td>checked</td><td>Boolean that is true if the menu item is checked.</td></tr>
<tr valign="top" class="odd"><td>font</td><td>The <a href="qfont.html">QFont</a> to use for the menu item's text.</td></tr>
<tr valign="top" class="even"><td>icon</td><td>the <a href="qicon.html">QIcon</a> of the menu item.</td></tr>
<tr valign="top" class="odd"><td>maxIconWidth</td><td>The maximum width allowed for the icon</td></tr>
<tr valign="top" class="even"><td>menuHasChecableItem</td><td>Boolean which is true if at least one item in the menu is checkable.</td></tr>
<tr valign="top" class="odd"><td>menuItemType</td><td>The type of the menu item. This a value of the <a href="qstyleoptionmenuitem.html#MenuItemType-enum">MenuItemType</a>.</td></tr>
<tr valign="top" class="even"><td>menuRect</td><td>The bounding rectangle for the <a href="qmenu.html">QMenu</a> that the menu item lives in.</td></tr>
<tr valign="top" class="odd"><td>tabWidth</td><td>This is the distance between the text of the menu item and the shortcut.</td></tr>
<tr valign="top" class="even"><td>text</td><td>The text of the menu item.</td></tr>
</table></p>
<p>The setup of the style option for CE_MenuTearOff and CE_MenuScroller also uses <a href="qstyleoptionmenuitem.html">QStyleOptionMenuItem</a>; they only set the <tt>menuRect</tt> variable in addition to the common settings with <a href="qstyleoption.html">QStyleOption</a>'s <a href="qstyleoption-obsolete.html#init">init()</a>.</p>
<a name="menu-bar"></a>
<h5>Menu Bar</h5>
<p><a href="qmenubar.html">QMenuBar</a> uses the style to draw each menu bar item and the empty area of the menu bar. The pull-down menus themselves are <a href="qmenu.html">QMenu</a>s (see <a href="#menus">Menus</a>). The style element tree for the menu bar follows:</p>
<p align="center"><img src="images//menubar.png" /></p><p>The panel and empty area is drawn after the menu items. The <a href="qpainter.html">QPainter</a> that the <a href="qmenubar.html">QMenuBar</a> sends to the style has the bounding rectangles of the items clipped out (i.e&#x2e;, clip region), so you don't need to worry about drawing over the items. The pixel metrics in <a href="qmenubar.html">QMenuBar</a> is used when the bounding rectangles of the menu bar items are calculated.</p>
<p align="center"><img src="images//menubarimage.png" /></p><p><a href="qstyleoptionmenuitem.html">QStyleOptionMenuItem</a> is used for menu bar items. The members that are used by <a href="qmenubar.html">QMenuBar</a> is described in the following table:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>menuRect</td><td>the bounding rectangle of the entire menu bar to which the item belongs.</td></tr>
<tr valign="top" class="even"><td>text</td><td>the text of the item</td></tr>
<tr valign="top" class="odd"><td>icon</td><td>the icon of the menu item (it is not common that styles draw this icon)</td></tr>
</table></p>
<p><a href="qstyleoptionmenuitem.html">QStyleOptionMenuItem</a> is also used for drawing CE_EmptyMenuBarArea.</p>
<p><a href="qstyleoptionframe.html">QStyleOptionFrame</a> is used for drawing the panel frame The <a href="qstyleoptionframe.html#lineWidth-var">lineWidth</a> is set to PM_MenuBarPanelWidth. The <a href="qstyleoptionframe.html#midLineWidth-var">midLineWidth</a> is currently always set to 0.</p>
<a name="item-view-headers"></a>
<h5>Item View Headers</h5>
<p>It is the style that draws the headers of Qt's item views. The item views keeps the dimensions on individual sections. Also note that the delegates may use the style to paint decorations and frames around items. <a href="qitemdelegate.html">QItemDelegate</a>, for instance, draws PE_FrameFocusRect and PE_IndicatorViewItemCheck.</p>
<p align="center"><img src="images//header.png" /></p><p>Here is a <a href="qtablewidget.html">QTableWidget</a> showing the bounding rects of a Java header:</p>
<p align="center"><img src="images//headerimage.png" /></p><p>The <a href="qheaderview.html">QHeaderView</a> uses CT_HeaderSection, PM_HeaderMargin and PM_HeaderGripMargin for size and hit test calculations. The PM_HeaderMarkSize is currently not used by Qt. <a href="qtableview.html">QTableView</a> draws the button in the top-left corner (i.e&#x2e;, the area where the vertical and horizontal headers intersect) as a CE_Header.</p>
<p>The style option for header views is <a href="qstyleoptionheader.html">QStyleOptionHeader</a>. The view paints one header section at a time, so the data is for the section being drawn. Its contents are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>icon</td><td>the icon of the header (for section that is being drawn).</td></tr>
<tr valign="top" class="even"><td>iconAlignment</td><td>the alignment (<a href="qt.html#AlignmentFlag-enum">Qt::Alignment</a>) of the icon in the header.</td></tr>
<tr valign="top" class="odd"><td>orientation</td><td>a <a href="qt.html#Orientation-enum">Qt::Orientation</a> value deciding whether the header is the horizontal header above the view or the vertical header on the left.</td></tr>
<tr valign="top" class="even"><td>position</td><td>a <a href="qstyleoptionheader.html#SectionPosition-enum">QStyleOptionHeader::SectionPosition</a> value giving the header section's position relative to the other sections.</td></tr>
<tr valign="top" class="odd"><td>section</td><td>holds the section that is being drawn.</td></tr>
<tr valign="top" class="even"><td>selectedPosition</td><td>a <a href="qstyleoptionheader.html#SelectedPosition-enum">QStyleOptionHeader::SelectedPosition</a> value giving the selected section's position relative to the section that is being painted.</td></tr>
<tr valign="top" class="odd"><td>sortIndicator</td><td>a <a href="qstyleoptionheader.html#SortIndicator-enum">QStyleOptionHeader::SortIndicator</a> value that describes the direction in which the section's sort indicator should be drawn.</td></tr>
<tr valign="top" class="even"><td>text</td><td>the text of the currently drawn section.</td></tr>
<tr valign="top" class="odd"><td>textAlignment</td><td>the <a href="qt.html#AlignmentFlag-enum">Qt::Alignment</a> of the text within the headersection.</td></tr>
</table></p>
<a name="tree-branch-indicators"></a>
<h5>Tree Branch Indicators</h5>
<p>The branch indicators in a tree view is drawn by the style with PE_IndicatorBranch. We think of indicators here as the indicators that describe the relationship of the nodes in the tree. The generic <a href="qstyleoption.html">QStyleOption</a> is sent to the style for drawing this elements. The various branch types are described by states. Since there are no specific style option, we simply present the states table:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>State</th><th>Set When</th></tr></thead>
<tr valign="top" class="odd"><td>State_Sibling</td><td>the node in the tree has a sibling (i.e&#x2e;, there is another node in the same column).</td></tr>
<tr valign="top" class="even"><td>State_Item</td><td>this branch indicator has an item.</td></tr>
<tr valign="top" class="odd"><td>State_Children</td><td>the branch has children (i.e&#x2e;, a new sub-tree can be opened at the branch).</td></tr>
<tr valign="top" class="even"><td>State_Open</td><td>the branch indicator has an opened sub-tree.</td></tr>
</table></p>
<p>The tree view (and tree widget) use the style to draw the branches (or nodes if you will) of the tree.</p>
<p><a href="qstyleoption.html">QStyleOption</a> is used as the style for PE_IndicatorBranch has state flags set depending on what type of branch it is.</p>
<p>Since there is no tree structure for branch indicators, we only present an image of a tree in the java style. Each state is marked in the image with a rectangle in a specific color (i.e&#x2e;, these rectangles are not bounding rectangles). All combinations of states you must be aware of are represented in the image.</p>
<p align="center"><img src="images//branchindicatorimage.png" /></p><a name="tool-boxes"></a>
<h5>Tool Boxes</h5>
<p>PM_SmallIconSize for sizeHints.</p>
<p><a href="qtoolbox.html">QToolBox</a> is a container that keeps a collection of widgets. It has one tab for each widget and display one of them at a time. The tool box lays the components it displays (the tool box buttons and selected widget) in a <a href="qvboxlayout.html">QVBoxLayout</a>. The style tree for tool boxes looks like this:</p>
<p align="center"><img src="images//toolbox.png" /></p><p>We show an image of a tool box in the Plastique style:</p>
<p align="center"><img src="images//toolboximage.png" /></p><p>All elements have the same bounding rectangles in the Plastique as well as the other Qt built-in styles.</p>
<p>The style option for tool boxes is <a href="qstyleoptiontoolbox.html">QStyleOptionToolBox</a>. It contains the text and icon of the tool box contents. The only state set by <a href="qtoolbox.html">QToolBox</a> is State_Sunken, which is set when the user presses a tab down with the mouse. The rest of the <a href="qstyleoptiontoolbox.html">QStyleOptionToolBox</a> members are:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>icon</td><td>the icon on the toolbox tab</td></tr>
<tr valign="top" class="even"><td>text</td><td>the text on the toolbox tab</td></tr>
</table></p>
<a name="size-grip"></a>
<h5>Size Grip</h5>
<p>The size grip calculates its size hint with CT_SizeGrip. The pixel metric PM_SizeGripSize is currently unused by Qt. The element tree for and an image in the Plastique style of <a href="qsizegrip.html">QSizeGrip</a> follows:</p>
<p align="center"><img src="images//sizegrip.png" /></p><p align="center"><img src="images//sizegripimage.png" /></p><p>We show the size grip in a <a href="qmainwindow.html">QMainWindow</a>'s bottom right corner.</p>
<p>The size grip style option, <a href="qstyleoptionsizegrip.html">QStyleOptionSizeGrip</a>, have one member except the common members from <a href="qstyleoption.html">QStyleOption</a>:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>corner</td><td>a <a href="qt.html#Corner-enum">Qt::Corner</a> value that describe which corner in a window (or equivalent) the grip is located.</td></tr>
</table></p>
<a name="rubber-band"></a>
<h5>Rubber Band</h5>
<p>The <a href="qrubberband.html">QRubberBand</a>'s style tree consists of two nodes.</p>
<p align="center"><img src="images//rubberband.png" /></p><p>We present an image of a Java style window being moved in a <a href="qmdiarea.html">QMdiArea</a> with a rubber band:</p>
<p align="center"><img src="images//rubberbandimage.png" /></p><p>The style option for rubber bands is <a href="qstyleoptionrubberband.html">QStyleOptionRubberBand</a>. Its members are:</p>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>opaque</td><td>boolean that is true if the rubber band must be drawn in an opaque style (i.e&#x2e;, color)</td></tr>
<tr valign="top" class="even"><td>shape</td><td>a <a href="qrubberband.html#Shape-enum">QRubberBand::Shape</a> enum value that holds the shape of the band (which is either a rectangle or a line)</td></tr>
</table></p>
<a name="dock-widgets"></a>
<h5>Dock Widgets</h5>
<p>When the dock widget lays out its contents it asks the style for these pixel metrics: PM_DockWidgetSeparatorExtent, PM_DockWidgetTitleBarButtonMargin, PM_DockWidgetFrameWidth, and PM_DockWidgetTitleMargin. It also calculates the bounding rectangles of the float and close buttons with SE_DockWidgetCloseButton and SE_DockWidgetFloatButton.</p>
<p align="center"><img src="images//dockwidget.png" /></p><p>The dotted lines indicate that the sender keeps instances of the recipient of the arrow (i.e&#x2e;, it is not a style element to draw). The dock widget only draws PE_frameDockWidget when it is detached from its main window (i.e&#x2e;, it is a top level window). If it is docked it draws the indicator dock widget resize handle. We show a dock widget in both docked and floating state in the plastique style:</p>
<p align="center"><img src="images//dockwidgetimage.png" /></p><p>The style option is <a href="qstyleoptiondockwidget.html">QStyleOptionDockWidget</a>:</p>
<p><table width="90%" align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Member</th><th>Content</th></tr></thead>
<tr valign="top" class="odd"><td>closeable</td><td>boolean that holds whether the dock window can be closed</td></tr>
<tr valign="top" class="even"><td>floatable</td><td>boolean that holds whether the dock window can float (i.e&#x2e;, detach from the main window in which it lives)</td></tr>
<tr valign="top" class="odd"><td>movable</td><td>boolean that holds whether the window is movable (i.e&#x2e;, can move to other dock widget areas)</td></tr>
<tr valign="top" class="even"><td>title</td><td>the title text of the dock window</td></tr>
</table></p>
<p>For the buttons, <a href="qstyleoptionbutton.html">QStyleOptionButton</a> is used (see <a href="#tool-buttons">Tool Buttons</a> for content description). The dock widget resize handle has a plain <a href="qstyleoption.html">QStyleOption</a>.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008 <a href="trolltech.html">Trolltech</a></td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.3.5</div></td>
</tr></table></div></address></body>
</html>
