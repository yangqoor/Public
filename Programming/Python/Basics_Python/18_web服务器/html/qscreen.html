<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- /fasttmp/mkdist-qt-4.3.5-1211793125/qtopia-core-opensource-src-4.3.5/src/gui/embedded/qscreen_qws.cpp -->
<head>
  <title>Qt 4.3: QScreen Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><a href="http://www.trolltech.com"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></a></td></tr></table><h1 align="center">QScreen Class Reference<br /><sup><sup>[<a href="qtgui.html">QtGui</a> module]</sup></sup></h1>
<p>The QScreen class is a base class for screen drivers in Qtopia Core. <a href="#details">More...</a></p>
<pre> #include &lt;QScreen&gt;</pre><ul>
<li><a href="qscreen-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>enum <b><a href="qscreen.html#PixelType-enum">PixelType</a></b> { NormalPixel, BGRPixel }</li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qscreen.html#QScreen">QScreen</a></b> ( int <i>displayId</i> )</li>
<li><div class="fn"/>virtual <b><a href="qscreen.html#dtor.QScreen">~QScreen</a></b> ()</li>
<li><div class="fn"/>virtual int <b><a href="qscreen.html#alloc">alloc</a></b> ( unsigned int <i>red</i>, unsigned int <i>green</i>, unsigned int <i>blue</i> )</li>
<li><div class="fn"/>uchar * <b><a href="qscreen.html#base">base</a></b> () const</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#blank">blank</a></b> ( bool <i>on</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#blit">blit</a></b> ( const QImage &amp; <i>image</i>, const QPoint &amp; <i>topLeft</i>, const QRegion &amp; <i>region</i> )</li>
<li><div class="fn"/>QRgb * <b><a href="qscreen.html#clut">clut</a></b> ()</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#connect">connect</a></b> ( const QString &amp; <i>displaySpec</i> ) = 0</li>
<li><div class="fn"/>virtual QWSWindowSurface * <b><a href="qscreen.html#createSurface">createSurface</a></b> ( const QString &amp; <i>key</i> ) const</li>
<li><div class="fn"/>virtual QWSWindowSurface * <b><a href="qscreen.html#createSurface-2">createSurface</a></b> ( QWidget * <i>widget</i> ) const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#depth">depth</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#deviceHeight">deviceHeight</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#deviceWidth">deviceWidth</a></b> () const</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#disconnect">disconnect</a></b> () = 0</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#exposeRegion">exposeRegion</a></b> ( QRegion <i>region</i>, int <i>windowIndex</i> )</li>
<li><div class="fn"/>int <b><a href="qscreen.html#height">height</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#initDevice">initDevice</a></b> () = 0</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#isInterlaced">isInterlaced</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#isTransformed">isTransformed</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#linestep">linestep</a></b> () const</li>
<li><div class="fn"/>virtual QSize <b><a href="qscreen.html#mapFromDevice">mapFromDevice</a></b> ( const QSize &amp; <i>size</i> ) const</li>
<li><div class="fn"/>virtual QPoint <b><a href="qscreen.html#mapFromDevice-2">mapFromDevice</a></b> ( const QPoint &amp; <i>point</i>, const QSize &amp; <i>screenSize</i> ) const</li>
<li><div class="fn"/>virtual QRect <b><a href="qscreen.html#mapFromDevice-3">mapFromDevice</a></b> ( const QRect &amp; <i>rectangle</i>, const QSize &amp; <i>screenSize</i> ) const</li>
<li><div class="fn"/>virtual QImage <b><a href="qscreen.html#mapFromDevice-4">mapFromDevice</a></b> ( const QImage &amp; <i>image</i> ) const</li>
<li><div class="fn"/>virtual QRegion <b><a href="qscreen.html#mapFromDevice-5">mapFromDevice</a></b> ( const QRegion &amp; <i>region</i>, const QSize &amp; <i>screenSize</i> ) const</li>
<li><div class="fn"/>virtual QSize <b><a href="qscreen.html#mapToDevice">mapToDevice</a></b> ( const QSize &amp; <i>size</i> ) const</li>
<li><div class="fn"/>virtual QPoint <b><a href="qscreen.html#mapToDevice-2">mapToDevice</a></b> ( const QPoint &amp; <i>point</i>, const QSize &amp; <i>screenSize</i> ) const</li>
<li><div class="fn"/>virtual QRect <b><a href="qscreen.html#mapToDevice-3">mapToDevice</a></b> ( const QRect &amp; <i>rectangle</i>, const QSize &amp; <i>screenSize</i> ) const</li>
<li><div class="fn"/>virtual QImage <b><a href="qscreen.html#mapToDevice-4">mapToDevice</a></b> ( const QImage &amp; <i>image</i> ) const</li>
<li><div class="fn"/>virtual QRegion <b><a href="qscreen.html#mapToDevice-5">mapToDevice</a></b> ( const QRegion &amp; <i>region</i>, const QSize &amp; <i>screenSize</i> ) const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#numCols">numCols</a></b> ()</li>
<li><div class="fn"/>QPoint <b><a href="qscreen.html#offset">offset</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#onCard">onCard</a></b> ( const unsigned char * <i>buffer</i> ) const</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#onCard-2">onCard</a></b> ( const unsigned char * <i>buffer</i>, ulong &amp; <i>offset</i> ) const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#physicalHeight">physicalHeight</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#physicalWidth">physicalWidth</a></b> () const</li>
<li><div class="fn"/>QImage::Format <b><a href="qscreen.html#pixelFormat">pixelFormat</a></b> () const</li>
<li><div class="fn"/>PixelType <b><a href="qscreen.html#pixelType">pixelType</a></b> () const</li>
<li><div class="fn"/>virtual int <b><a href="qscreen.html#pixmapDepth">pixmapDepth</a></b> () const</li>
<li><div class="fn"/>virtual int <b><a href="qscreen.html#pixmapLinestepAlignment">pixmapLinestepAlignment</a></b> ()</li>
<li><div class="fn"/>virtual int <b><a href="qscreen.html#pixmapOffsetAlignment">pixmapOffsetAlignment</a></b> ()</li>
<li><div class="fn"/>virtual QRegion <b><a href="qscreen.html#region">region</a></b> () const</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#restore">restore</a></b> ()</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#save">save</a></b> ()</li>
<li><div class="fn"/>int <b><a href="qscreen.html#screenSize">screenSize</a></b> () const</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#setDirty">setDirty</a></b> ( const QRect &amp; <i>rectangle</i> )</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#setMode">setMode</a></b> ( int <i>width</i>, int <i>height</i>, int <i>depth</i> ) = 0</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#shutdownDevice">shutdownDevice</a></b> ()</li>
<li><div class="fn"/>virtual void <b><a href="qscreen.html#solidFill">solidFill</a></b> ( const QColor &amp; <i>color</i>, const QRegion &amp; <i>region</i> )</li>
<li><div class="fn"/>int <b><a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a></b> ( const QPoint &amp; <i>position</i> ) const</li>
<li><div class="fn"/>virtual QList&lt;QScreen *&gt; <b><a href="qscreen.html#subScreens">subScreens</a></b> () const</li>
<li><div class="fn"/>virtual bool <b><a href="qscreen.html#supportsDepth">supportsDepth</a></b> ( int <i>depth</i> ) const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#totalSize">totalSize</a></b> () const</li>
<li><div class="fn"/>virtual int <b><a href="qscreen.html#transformOrientation">transformOrientation</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qscreen.html#width">width</a></b> () const</li>
</ul>
<a name="static-public-members"></a>
<h3>Static Public Members</h3>
<ul>
<li><div class="fn"/>QScreen * <b><a href="qscreen.html#instance">instance</a></b> ()</li>
</ul>
<a name="protected-functions"></a>
<h3>Protected Functions</h3>
<ul>
<li><div class="fn"/>void <b><a href="qscreen.html#setPixelFormat">setPixelFormat</a></b> ( QImage::Format <i>format</i> )</li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QScreen class is a base class for screen drivers in Qtopia Core.</p>
<p>Note that this class is only available in <a href="qtopiacore.html">Qtopia Core</a>.</p>
<p><a href="qtopiacore.html">Qtopia Core</a> provides ready-made drivers for several screen protocols, see the <a href="qtopiacore-displaymanagement.html">display management</a> documentation for details. Custom screen drivers can be implemented by subclassing the QScreen class and creating a screen driver plugin (derived from <a href="qscreendriverplugin.html">QScreenDriverPlugin</a>). <a href="qtopiacore.html">Qtopia Core</a>'s implementation of the <a href="qscreendriverfactory.html">QScreenDriverFactory</a> class will automatically detect the plugin, and load the driver into the server application at runtime using Qt's <a href="plugins-howto.html">plugin system</a>.</p>
<p>When rendering, <a href="qtopiacore.html">Qtopia Core</a>'s default behavior is for each client to render its widgets as well as its decorations into memory, while the server copies the memory content to the device's framebuffer using the screen driver. See the <a href="qtopiacore-architecture.html">Qtopia Core Architecture</a> overview for details (note that it is possible for the clients to manipulate and control the underlying hardware directly as well).</p>
<p>Starting with <a href="qtopiacore.html">Qtopia Core</a> 4.2, it is also possible to add an accelerated graphics driver to take advantage of available hardware resources. See the <a href="qtopiacore-accel.html">Adding an Accelerated Graphics Driver in Qtopia Core</a> documentation for details.</p>
<ul><li><a href="#framebuffer-management">Framebuffer Management</a></li>
<li><a href="#palette-management">Palette Management</a></li>
<li><a href="#drawing-on-screen">Drawing on Screen</a></li>
<li><a href="#properties">Properties</a></li>
</ul>
<a name="framebuffer-management"></a>
<h3>Framebuffer Management</h3>
<p>When a <a href="qtopiacore.html">Qtopia Core</a> application starts running, it calls the screen driver's <a href="qscreen.html#connect">connect</a>() function to map into the framebuffer and the accelerated drivers that the graphics card control registers. Note that if the application acts as the server, the application will call the <a href="qscreen.html#initDevice">initDevice</a>() function prior to the <a href="qscreen.html#connect">connect</a>() function, to initialize the framebuffer. The <a href="qscreen.html#initDevice">initDevice</a>() function can be reimplemented to set up the graphics card.</p>
<p>Likewise, just before a <a href="qtopiacore.html">Qtopia Core</a> application exits, it calls the screen driver's <a href="qscreen.html#disconnect">disconnect</a>() function. The server application will in addition call the <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() function before it calls <a href="qscreen.html#disconnect">disconnect</a>(). Note that the default implementation of the <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() function only hides the mouse cursor.</p>
<p>QScreen also provides the <a href="qscreen.html#save">save</a>() and <a href="qscreen.html#restore">restore</a>() functions, making it possible to save and restore the state of the graphics card. Note that the default implementations do nothing. Hardware screen drivers should reimplement these functions to save (and restore) its registers, enabling switching between virtual consoles.</p>
<p>In addition, you can use the <a href="qscreen.html#base">base</a>() function to retrieve a pointer to the beginning of the framebuffer, and the <a href="qscreen.html#region">region</a>() function to retrieve the framebuffer's region. Use the <a href="qscreen.html#onCard">onCard</a>() function to determine whether the framebuffer is within the graphics card's memory, and the <a href="qscreen.html#totalSize">totalSize</a>() function to determine the size of the available graphics card memory (including the screen). Finally, you can use the <a href="qscreen.html#offset">offset</a>() function to retrieve the offset between the framebuffer's coordinates and the application's coordinate system.</p>
<a name="palette-management"></a>
<h3>Palette Management</h3>
<p>QScreen provides several functions to retrieve information about the color palette: The <a href="qscreen.html#clut">clut</a>() function returns a pointer to the color lookup table (i.e&#x2e; its color palette). Use the <a href="qscreen.html#numCols">numCols</a>() function to determine the number of entries in this table, and the <a href="qscreen.html#alloc">alloc</a>() function to retrieve the palette index of the color that is the closest match to a given RGB value.</p>
<p>To determine if the screen driver supports a given color depth, use the <a href="qscreen.html#supportsDepth">supportsDepth</a>() function that returns true of the specified depth is supported.</p>
<a name="drawing-on-screen"></a>
<h3>Drawing on Screen</h3>
<p>When a screen update is required, the <a href="qtopiacore.html">Qtopia Core</a> server runs through all the top-level windows that intersect with the region that is about to be updated, and ensures that the associated clients have updated their memory buffer. Then the server calls the <a href="qscreen.html#exposeRegion">exposeRegion</a>() function that composes the window surfaces and copies the content of memory to screen by calling the <a href="qscreen.html#blit">blit</a>() and <a href="qscreen.html#solidFill">solidFill</a>() functions.</p>
<p>The <a href="qscreen.html#blit">blit</a>() function copies a given region in a given image to a specified point using device coordinates, while the <a href="qscreen.html#solidFill">solidFill</a>() function fills the given region of the screen with the specified color. Note that normally there is no need to call either of these functions explicitly.</p>
<p>In addition, QScreen provides the <a href="qscreen.html#blank">blank</a>() function that can be reimplemented to prevent any contents from being displayed on the screen, and the <a href="qscreen.html#setDirty">setDirty</a>() function that can be reimplemented to indicate that a given rectangle of the screen has been altered. Note that the default implementations of these functions do nothing.</p>
<p>Reimplement the the <a href="qscreen.html#mapFromDevice">mapFromDevice</a>() and <a href="qscreen.html#mapToDevice">mapToDevice</a>() functions to map objects from the framebuffer coordinate system to the coordinate space used by the application, and vice versa. Be aware that the default implementations simply return the given objects as they are.</p>
<a name="properties"></a>
<h3>Properties</h3>
<p><table align="center" cellpadding="2" cellspacing="1" border="0">
<thead><tr valign="top" class="qt-style"><th>Property</th><th>Functions</th></tr></thead>
<tr valign="top" class="odd"><td>Size</td><td>The size of the screen can be retrieved using the <a href="qscreen.html#screenSize">screenSize</a>() function. The size is returned in bytes.<p>The framebuffer's logical width and height can be retrieved using <a href="qscreen.html#width">width</a>() and <a href="qscreen.html#height">height</a>(), respectively. These functions return values are given in pixels. Alternatively, the <a href="qscreen.html#physicalWidth">physicalWidth</a>() and <a href="qscreen.html#physicalHeight">physicalHeight</a>() function returns the same metrics in millimeters. QScreen also provides the <a href="qscreen.html#deviceWidth">deviceWidth</a>() and <a href="qscreen.html#deviceHeight">deviceHeight</a>() functions returning the physical width and height of the device in pixels. Note that the latter metrics can differ from the ones used if the display is centered within the framebuffer.</p>
</td></tr>
<tr valign="top" class="even"><td>Resolution</td><td>Reimplement the <a href="qscreen.html#setMode">setMode</a>() function to be able to set the framebuffer to a new resolution (width and height) and bit depth.<p>The current depth of the framebuffer can be always be retrieved using the <a href="qscreen.html#depth">depth</a>() function. Use the <a href="qscreen.html#pixmapDepth">pixmapDepth</a>() function to obtain the preferred depth for pixmaps.</p>
</td></tr>
<tr valign="top" class="odd"><td>Pixmap Alignment</td><td>Use the <a href="qscreen.html#pixmapOffsetAlignment">pixmapOffsetAlignment</a>() function to retrieve the value to which the start address of pixmaps held in the graphics card's memory, should be aligned.<p>Use the <a href="qscreen.html#pixmapLinestepAlignment">pixmapLinestepAlignment</a>() to retrieve the value to which the <i>individual scanlines</i> of pixmaps should be aligned.</p>
</td></tr>
<tr valign="top" class="even"><td>Image Display</td><td>The <a href="qscreen.html#isInterlaced">isInterlaced</a>() function tells whether the screen is displaying images progressively, and the <a href="qscreen.html#isTransformed">isTransformed</a>() function whether it is rotated. The <a href="qscreen.html#transformOrientation">transformOrientation</a>() function can be reimplemented to return the current rotation.</td></tr>
<tr valign="top" class="odd"><td>Scanlines</td><td>Use the <a href="qscreen.html#linestep">linestep</a>() function to retrieve the length of each scanline of the framebuffer.</td></tr>
<tr valign="top" class="even"><td>Pixel Type</td><td>The <a href="qscreen.html#pixelType">pixelType</a>() function returns the screen's pixel storage format as described by the <a href="qscreen.html#PixelType-enum">PixelType</a> enum.</td></tr>
</table></p>
<p>See also <a href="qscreendriverplugin.html">QScreenDriverPlugin</a>, <a href="qscreendriverfactory.html">QScreenDriverFactory</a>, and <a href="qtopiacore-displaymanagement.html">Qtopia Core Display Management</a>.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="PixelType-enum"></a>enum QScreen::PixelType</h3>
<p>This enum describes the pixel storage format of the screen, i.e&#x2e; the order of the red (R), green (G) and blue (B) components of a pixel.</p>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QScreen::NormalPixel</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">Red-green-blue (RGB)</td></tr>
<tr><td valign="top"><tt>QScreen::BGRPixel</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">Blue-green-red (BGR)</td></tr>
</table></p>
<p>See also <a href="qscreen.html#pixelType">pixelType</a>().</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="QScreen"></a>QScreen::QScreen ( int <i>displayId</i> )</h3>
<p>Constructs a new screen driver.</p>
<p>The <i>displayId</i> identifies the <a href="qtopiacore.html">Qtopia Core</a> server to connect to.</p>
<h3 class="fn"><a name="dtor.QScreen"></a>QScreen::~QScreen ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Destroys this screen driver.</p>
<h3 class="fn"><a name="alloc"></a>int QScreen::alloc ( unsigned int <i>red</i>, unsigned int <i>green</i>, unsigned int <i>blue</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the index in the screen's palette which is the closest match to the given RGB value (<i>red</i>, <i>green</i>, <i>blue</i>).</p>
<p>Note that this function only apply in paletted modes like 8-bit, i.e&#x2e; in modes where only the palette indexes (and not the actual color values) are stored in memory.</p>
<p>See also <a href="qscreen.html#clut">clut</a>() and <a href="qscreen.html#numCols">numCols</a>().</p>
<h3 class="fn"><a name="base"></a><a href="qtglobal.html#uchar-typedef">uchar</a> * QScreen::base () const</h3>
<p>Returns a pointer to the beginning of the framebuffer.</p>
<p>See also <a href="qscreen.html#onCard">onCard</a>(), <a href="qscreen.html#region">region</a>(), and <a href="qscreen.html#totalSize">totalSize</a>().</p>
<h3 class="fn"><a name="blank"></a>void QScreen::blank ( bool <i>on</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Prevents the screen driver form displaying any content on the screen.</p>
<p>Note that the default implementation does nothing.</p>
<p>Reimplement this function to prevent the screen driver from displaying any contents on the screen if <i>on</i> is true; otherwise the contents is expected to be shown.</p>
<p>See also <a href="qscreen.html#blit">blit</a>().</p>
<h3 class="fn"><a name="blit"></a>void QScreen::blit ( const <a href="qimage.html">QImage</a> &amp; <i>image</i>, const <a href="qpoint.html">QPoint</a> &amp; <i>topLeft</i>, const <a href="qregion.html">QRegion</a> &amp; <i>region</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Copies the given <i>region</i> in the given <i>image</i> to the point specified by <i>topLeft</i> using device coordinates.</p>
<p>This function is called from the <a href="qscreen.html#exposeRegion">exposeRegion</a>() function; it is not intended to be called explicitly.</p>
<p>Reimplement this function to make use of <a href="qtopiacore-accel.html">accelerated hardware</a>. Note that this function must be reimplemented if the framebuffer format is not supported by <a href="qtopiacore.html">Qtopia Core</a> (See the <a href="qtopiacore-displaymanagement.html">Display Management</a> documentation for more details).</p>
<p>See also <a href="qscreen.html#exposeRegion">exposeRegion</a>(), <a href="qscreen.html#solidFill">solidFill</a>(), and <a href="qscreen.html#blank">blank</a>().</p>
<h3 class="fn"><a name="clut"></a><a href="qcolor.html#QRgb-typedef">QRgb</a> * QScreen::clut ()</h3>
<p>Returns a pointer to the screen's color lookup table (i.e&#x2e; its color palette).</p>
<p>Note that this function only apply in paletted modes like 8-bit, i.e&#x2e; in modes where only the palette indexes (and not the actual color values) are stored in memory.</p>
<p>See also <a href="qscreen.html#alloc">alloc</a>(), <a href="qscreen.html#depth">depth</a>(), and <a href="qscreen.html#numCols">numCols</a>().</p>
<h3 class="fn"><a name="connect"></a>bool QScreen::connect ( const <a href="qstring.html">QString</a> &amp; <i>displaySpec</i> )&nbsp;&nbsp;<tt> [pure virtual]</tt></h3>
<p>This function is called by every <a href="qtopiacore.html">Qtopia Core</a> application on startup, and must be implemented to map in the framebuffer and the accelerated drivers that the graphics card control registers. Note that it is called <i>before</i> the <a href="qscreen.html#initDevice">initDevice</a>() function.</p>
<p>Ensure that the function returns true if a connection to the screen device can be made; otherwise return false.</p>
<p>The <i>displaySpec</i> argument is passed by the <a href="qtopiacore-envvars.html#qws-display">QWS_DISPLAY</a> environment variable or the -display command line parameter, and has the following syntax:</p>
<pre> [screen driver][:driver specific options][:display number]</pre>
<p>For example, to use the mach64 driver on fb1 as display 2:</p>
<pre> Mach64:/dev/fb1:2</pre>
<p>See <a href="qtopiacore-displaymanagement.html">Qtopia Core Display Management</a> for more details.</p>
<p>See also <a href="qscreen.html#disconnect">disconnect</a>(), <a href="qscreen.html#initDevice">initDevice</a>(), and <a href="qtopiacore-running.html">Running Qtopia Core Applications</a>.</p>
<h3 class="fn"><a name="createSurface"></a>QWSWindowSurface * QScreen::createSurface ( const <a href="qstring.html">QString</a> &amp; <i>key</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Creates and returns a new window surface matching the given <i>key</i>. Possible keys include <i>OnScreen</i> for an on-screen surface, <i>mem</i> for a surface constructed from local memory, <i>shm</i> for a surface constructed from shared memory, <i>Yellow</i> for a yellow surface, and <i>DirectPainter</i> for a direct painter surface.</p>
<p>The server application will call this function whenever it needs to create a server side representation of a window, e.g&#x2e; when copying the content of memory to the screen using the screen driver.</p>
<p>Note that this function must be reimplemented when adding an accelerated graphics driver. See the <a href="qtopiacore-accel.html">Adding an Accelerated Graphics Driver</a> documentation for details.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qtopiacore-architecture.html">Qtopia Core Architecture</a>.</p>
<h3 class="fn"><a name="createSurface-2"></a>QWSWindowSurface * QScreen::createSurface ( <a href="qwidget.html">QWidget</a> * <i>widget</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Creates and returns a new window surface for the given <i>widget</i>.</p>
<h3 class="fn"><a name="depth"></a>int QScreen::depth () const</h3>
<p>Returns the depth of the framebuffer, in bits per pixel.</p>
<p>Note that the returned depth is the number of bits each pixel fills rather than the number of significant bits, so 24bpp and 32bpp express the same range of colors (8 bits of red, green and blue).</p>
<p>See also <a href="qscreen.html#clut">clut</a>() and <a href="qscreen.html#pixmapDepth">pixmapDepth</a>().</p>
<h3 class="fn"><a name="deviceHeight"></a>int QScreen::deviceHeight () const</h3>
<p>Returns the full height of the framebuffer device in pixels.</p>
<p>Note that the returned height can differ from the height which <a href="qtopiacore.html">Qtopia Core</a> will actually use, that is if the display is centered within the framebuffer.</p>
<p>See also <a href="qscreen.html#height">height</a>(), <a href="qscreen.html#physicalHeight">physicalHeight</a>(), and <a href="qscreen.html#deviceWidth">deviceWidth</a>().</p>
<h3 class="fn"><a name="deviceWidth"></a>int QScreen::deviceWidth () const</h3>
<p>Returns the physical width of the framebuffer device in pixels.</p>
<p>Note that the returned width can differ from the width which <a href="qtopiacore.html">Qtopia Core</a> will actually use, that is if the display is centered within the framebuffer.</p>
<p>See also <a href="qscreen.html#width">width</a>(), <a href="qscreen.html#physicalWidth">physicalWidth</a>(), and <a href="qscreen.html#deviceHeight">deviceHeight</a>().</p>
<h3 class="fn"><a name="disconnect"></a>void QScreen::disconnect ()&nbsp;&nbsp;<tt> [pure virtual]</tt></h3>
<p>This function is called by every <a href="qtopiacore.html">Qtopia Core</a> application before exiting, and must be implemented to unmap the framebuffer. Note that a server application will call the <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() function prior to this function.</p>
<p>See also <a href="qscreen.html#connect">connect</a>(), <a href="qscreen.html#shutdownDevice">shutdownDevice</a>(), and <a href="qtopiacore-running.html">Running Qtopia Core Applications</a>.</p>
<h3 class="fn"><a name="exposeRegion"></a>void QScreen::exposeRegion ( <a href="qregion.html">QRegion</a> <i>region</i>, int <i>windowIndex</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This function is called by the <a href="qtopiacore.html">Qtopia Core</a> server whenever a screen update is required. <i>region</i> is the area on the screen that must be updated, and <i>windowIndex</i> is the index into <a href="qwsserver.html#clientWindows">QWSServer::clientWindows</a>() of the window that required the update. <a href="qwswindow.html#state">QWSWindow::state</a>() gives more information about the cause.</p>
<p>The default implementation composes the affected windows and paints the given <i>region</i> on screen by calling the <a href="qscreen.html#blit">blit</a>() and <a href="qscreen.html#solidFill">solidFill</a>() functions</p>
<p>This function can be reimplemented to perform composition in hardware, or to perform transition effects. For simpler hardware acceleration, or to interface with this is typically done by reimplementing the <a href="qscreen.html#blit">blit</a>() and <a href="qscreen.html#solidFill">solidFill</a>() functions instead.</p>
<p>Note that there is no need to call this function explicitly.</p>
<p>See also <a href="qscreen.html#blit">blit</a>(), <a href="qscreen.html#solidFill">solidFill</a>(), and <a href="qscreen.html#blank">blank</a>().</p>
<h3 class="fn"><a name="height"></a>int QScreen::height () const</h3>
<p>Returns the logical height of the framebuffer in pixels.</p>
<p>See also <a href="qscreen.html#deviceHeight">deviceHeight</a>(), <a href="qscreen.html#physicalHeight">physicalHeight</a>(), and <a href="qscreen.html#width">width</a>().</p>
<h3 class="fn"><a name="initDevice"></a>bool QScreen::initDevice ()&nbsp;&nbsp;<tt> [pure virtual]</tt></h3>
<p>This function is called by the <a href="qtopiacore.html">Qtopia Core</a> server to initialize the framebuffer. Note that a server application will call the <a href="qscreen.html#connect">connect</a>() function prior to this function.</p>
<p>Implement this function to make accelerated drivers set up the graphics card. Return true to indicate success and false to indicate failure.</p>
<p>See also <a href="qscreen.html#shutdownDevice">shutdownDevice</a>() and <a href="qscreen.html#connect">connect</a>().</p>
<h3 class="fn"><a name="instance"></a>QScreen * QScreen::instance ()&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a pointer to the application's <a href="qscreen.html">QScreen</a> instance.</p>
<p>If this screen consists of several subscreens, operations to the returned instance will affect all its subscreens. Use the subscreens() function to retrieve access to a particular subscreen.</p>
<p>See also <a href="qscreen.html#subScreens">subScreens</a>() and <a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a>().</p>
<h3 class="fn"><a name="isInterlaced"></a>bool QScreen::isInterlaced () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns true if the display is interlaced (i.e&#x2e; is displaying images progressively like a television screen); otherwise returns false.</p>
<p>If the display is interlaced, the drawing is altered to look better.</p>
<p>See also <a href="qscreen.html#isTransformed">isTransformed</a>() and <a href="qscreen.html#linestep">linestep</a>().</p>
<h3 class="fn"><a name="isTransformed"></a>bool QScreen::isTransformed () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns true if the screen is transformed (for instance, rotated 90 degrees); otherwise returns false.</p>
<p>See also <a href="qscreen.html#transformOrientation">transformOrientation</a>() and <a href="qscreen.html#isInterlaced">isInterlaced</a>().</p>
<h3 class="fn"><a name="linestep"></a>int QScreen::linestep () const</h3>
<p>Returns the length of each scanline of the framebuffer in bytes.</p>
<p>See also <a href="qscreen.html#isInterlaced">isInterlaced</a>().</p>
<h3 class="fn"><a name="mapFromDevice"></a><a href="qsize.html">QSize</a> QScreen::mapFromDevice ( const <a href="qsize.html">QSize</a> &amp; <i>size</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Maps the given <i>size</i> from the framebuffer coordinate system to the coordinate space used by the application. Note that the default implementation simply returns the given <i>size</i> as it is.</p>
<p>Reimplement this function to use the given device's coordinate system when mapping.</p>
<p>See also <a href="qscreen.html#mapToDevice">mapToDevice</a>().</p>
<h3 class="fn"><a name="mapFromDevice-2"></a><a href="qpoint.html">QPoint</a> QScreen::mapFromDevice ( const <a href="qpoint.html">QPoint</a> &amp; <i>point</i>, const <a href="qsize.html">QSize</a> &amp; <i>screenSize</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>point</i> from the framebuffer coordinate system to the coordinate space used by the application, passing the device's <i>screenSize</i> as argument. Note that the default implementation simply returns the given <i>point</i> as it is.</p>
<h3 class="fn"><a name="mapFromDevice-3"></a><a href="qrect.html">QRect</a> QScreen::mapFromDevice ( const <a href="qrect.html">QRect</a> &amp; <i>rectangle</i>, const <a href="qsize.html">QSize</a> &amp; <i>screenSize</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>rectangle</i> from the framebuffer coordinate system to the coordinate space used by the application, passing the device's <i>screenSize</i> as argument. Note that the default implementation simply returns the given <i>rectangle</i> as it is.</p>
<h3 class="fn"><a name="mapFromDevice-4"></a><a href="qimage.html">QImage</a> QScreen::mapFromDevice ( const <a href="qimage.html">QImage</a> &amp; <i>image</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>image</i> from the framebuffer coordinate system to the coordinate space used by the application. Note that the default implementation simply returns the given <i>image</i> as it is.</p>
<h3 class="fn"><a name="mapFromDevice-5"></a><a href="qregion.html">QRegion</a> QScreen::mapFromDevice ( const <a href="qregion.html">QRegion</a> &amp; <i>region</i>, const <a href="qsize.html">QSize</a> &amp; <i>screenSize</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>region</i> from the framebuffer coordinate system to the coordinate space used by the application, passing the device's <i>screenSize</i> as argument. Note that the default implementation simply returns the given <i>region</i> as it is.</p>
<h3 class="fn"><a name="mapToDevice"></a><a href="qsize.html">QSize</a> QScreen::mapToDevice ( const <a href="qsize.html">QSize</a> &amp; <i>size</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Maps the given <i>size</i> from the coordinate space used by the application to the framebuffer coordinate system. Note that the default implementation simply returns the given <i>size</i> as it is.</p>
<p>Reimplement this function to use the given device's coordinate system when mapping.</p>
<p>See also <a href="qscreen.html#mapFromDevice">mapFromDevice</a>().</p>
<h3 class="fn"><a name="mapToDevice-2"></a><a href="qpoint.html">QPoint</a> QScreen::mapToDevice ( const <a href="qpoint.html">QPoint</a> &amp; <i>point</i>, const <a href="qsize.html">QSize</a> &amp; <i>screenSize</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>point</i> from the coordinate space used by the application to the framebuffer coordinate system, passing the device's <i>screenSize</i> as argument. Note that the default implementation returns the given <i>point</i> as it is.</p>
<h3 class="fn"><a name="mapToDevice-3"></a><a href="qrect.html">QRect</a> QScreen::mapToDevice ( const <a href="qrect.html">QRect</a> &amp; <i>rectangle</i>, const <a href="qsize.html">QSize</a> &amp; <i>screenSize</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>rectangle</i> from the coordinate space used by the application to the framebuffer coordinate system, passing the device's <i>screenSize</i> as argument. Note that the default implementation returns the given <i>rectangle</i> as it is.</p>
<h3 class="fn"><a name="mapToDevice-4"></a><a href="qimage.html">QImage</a> QScreen::mapToDevice ( const <a href="qimage.html">QImage</a> &amp; <i>image</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>image</i> from the coordinate space used by the application to the framebuffer coordinate system. Note that the default implementation returns the given <i>image</i> as it is.</p>
<h3 class="fn"><a name="mapToDevice-5"></a><a href="qregion.html">QRegion</a> QScreen::mapToDevice ( const <a href="qregion.html">QRegion</a> &amp; <i>region</i>, const <a href="qsize.html">QSize</a> &amp; <i>screenSize</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Maps the given <i>region</i> from the coordinate space used by the application to the framebuffer coordinate system, passing the device's <i>screenSize</i> as argument. Note that the default implementation returns the given <i>region</i> as it is.</p>
<h3 class="fn"><a name="numCols"></a>int QScreen::numCols ()</h3>
<p>Returns the number of entries in the screen's color lookup table (i.e&#x2e; its color palette). A pointer to the color table can be retrieved using the <a href="qscreen.html#clut">clut</a>() function.</p>
<p>See also <a href="qscreen.html#clut">clut</a>() and <a href="qscreen.html#alloc">alloc</a>().</p>
<h3 class="fn"><a name="offset"></a><a href="qpoint.html">QPoint</a> QScreen::offset () const</h3>
<p>Returns the logical offset of the screen, i.e&#x2e;, the offset between (0,0) in screen coordinates and the application coordinate system.</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="onCard"></a>bool QScreen::onCard ( const unsigned char * <i>buffer</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns true if the specified <i>buffer</i> is within the graphics card's memory; otherwise returns false (i.e&#x2e; if it's in main RAM).</p>
<p>See also <a href="qscreen.html#base">base</a>() and <a href="qscreen.html#totalSize">totalSize</a>().</p>
<h3 class="fn"><a name="onCard-2"></a>bool QScreen::onCard ( const unsigned char * <i>buffer</i>, <a href="qtglobal.html#ulong-typedef">ulong</a> &amp; <i>offset</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>If the specified <i>buffer</i> is within the graphics card's memory, this function stores the offset from the start of graphics card memory (in bytes), in the location specified by the <i>offset</i> parameter.</p>
<h3 class="fn"><a name="physicalHeight"></a>int QScreen::physicalHeight () const</h3>
<p>Returns the physical height of the screen in millimeters.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qscreen.html#height">height</a>(), <a href="qscreen.html#deviceHeight">deviceHeight</a>(), and <a href="qscreen.html#physicalWidth">physicalWidth</a>().</p>
<h3 class="fn"><a name="physicalWidth"></a>int QScreen::physicalWidth () const</h3>
<p>Returns the physical width of the screen in millimeters.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qscreen.html#width">width</a>(), <a href="qscreen.html#deviceWidth">deviceWidth</a>(), and <a href="qscreen.html#physicalHeight">physicalHeight</a>().</p>
<h3 class="fn"><a name="pixelFormat"></a><a href="qimage.html#Format-enum">QImage::Format</a> QScreen::pixelFormat () const</h3>
<p>Returns the pixel format of the screen, or <tt>QImage::Format_Invalid</tt> if the pixel format is not a supported image format.</p>
<p>See also <a href="qscreen.html#setPixelFormat">setPixelFormat</a>().</p>
<h3 class="fn"><a name="pixelType"></a><a href="qscreen.html#PixelType-enum">PixelType</a> QScreen::pixelType () const</h3>
<p>Returns the pixel storage format of the screen.</p>
<h3 class="fn"><a name="pixmapDepth"></a>int QScreen::pixmapDepth () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the preferred depth for pixmaps, in bits per pixel.</p>
<p>See also <a href="qscreen.html#depth">depth</a>().</p>
<h3 class="fn"><a name="pixmapLinestepAlignment"></a>int QScreen::pixmapLinestepAlignment ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the value (in bits) to which individual scanlines of pixmaps held in the graphics card's memory, should be aligned.</p>
<p>Note that the default implementation returns 64; reimplement this function to override the return value, e.g&#x2e;, when implementing an accelerated driver (see the <a href="qtopiacore-accel.html">Adding an Accelerated Graphics Driver</a> documentation for details).</p>
<p>See also <a href="qscreen.html#pixmapOffsetAlignment">pixmapOffsetAlignment</a>().</p>
<h3 class="fn"><a name="pixmapOffsetAlignment"></a>int QScreen::pixmapOffsetAlignment ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the value (in bits) to which the start address of pixmaps held in the graphics card's memory, should be aligned.</p>
<p>Note that the default implementation returns 64; reimplement this function to override the return value, e.g&#x2e;, when implementing an accelerated driver (see the <a href="qtopiacore-accel.html">Adding an Accelerated Graphics Driver</a> documentation for details).</p>
<p>See also <a href="qscreen.html#pixmapLinestepAlignment">pixmapLinestepAlignment</a>().</p>
<h3 class="fn"><a name="region"></a><a href="qregion.html">QRegion</a> QScreen::region () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the region covered by this screen driver.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qscreen.html#base">base</a>() and <a href="qscreen.html#screenSize">screenSize</a>().</p>
<h3 class="fn"><a name="restore"></a>void QScreen::restore ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Restores the previously saved state of the graphics card.</p>
<p>For example, hardware screen drivers should reimplement the <a href="qscreen.html#save">save</a>() and restore() functions to save and restore its registers, enabling swintching between virtual consoles.</p>
<p>Note that the default implementation does nothing.</p>
<p>See also <a href="qscreen.html#save">save</a>().</p>
<h3 class="fn"><a name="save"></a>void QScreen::save ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Saves the current state of the graphics card.</p>
<p>For example, hardware screen drivers should reimplement the save() and <a href="qscreen.html#restore">restore</a>() functions to save and restore its registers, enabling swintching between virtual consoles.</p>
<p>Note that the default implementation does nothing.</p>
<p>See also <a href="qscreen.html#restore">restore</a>().</p>
<h3 class="fn"><a name="screenSize"></a>int QScreen::screenSize () const</h3>
<p>Returns the size of the screen in bytes.</p>
<p>The screen size is always located at the beginning of framebuffer memory, i.e&#x2e; it can also be retrieved using the <a href="qscreen.html#base">base</a>() function.</p>
<p>See also <a href="qscreen.html#base">base</a>() and <a href="qscreen.html#region">region</a>().</p>
<h3 class="fn"><a name="setDirty"></a>void QScreen::setDirty ( const <a href="qrect.html">QRect</a> &amp; <i>rectangle</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Marks the given <i>rectangle</i> as dirty.</p>
<p>Note that the default implementation does nothing; reimplement this function to indicate that the given <i>rectangle</i> has been altered.</p>
<h3 class="fn"><a name="setMode"></a>void QScreen::setMode ( int <i>width</i>, int <i>height</i>, int <i>depth</i> )&nbsp;&nbsp;<tt> [pure virtual]</tt></h3>
<p>Implement this function to reset the framebuffer's resolution (<i>width</i> and <i>height</i>) and bit <i>depth</i>.</p>
<p>After the resolution has been set, existing paint engines will be invalid and the framebuffer should be completely redrawn. In a multiple-process situation, all other applications must be notified to reset their mode and update themselves accordingly.</p>
<h3 class="fn"><a name="setPixelFormat"></a>void QScreen::setPixelFormat ( <a href="qimage.html#Format-enum">QImage::Format</a> <i>format</i> )&nbsp;&nbsp;<tt> [protected]</tt></h3>
<p>Sets the screen's pixel format to <i>format</i>.</p>
<p>See also <a href="qscreen.html#pixelFormat">pixelFormat</a>().</p>
<h3 class="fn"><a name="shutdownDevice"></a>void QScreen::shutdownDevice ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>This function is called by the <a href="qtopiacore.html">Qtopia Core</a> server before it calls the <a href="qscreen.html#disconnect">disconnect</a>() function when exiting.</p>
<p>Note that the default implementation only hides the mouse cursor; reimplement this function to do the necessary graphics card specific cleanup.</p>
<p>See also <a href="qscreen.html#initDevice">initDevice</a>() and <a href="qscreen.html#disconnect">disconnect</a>().</p>
<h3 class="fn"><a name="solidFill"></a>void QScreen::solidFill ( const <a href="qcolor.html">QColor</a> &amp; <i>color</i>, const <a href="qregion.html">QRegion</a> &amp; <i>region</i> )&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Fills the given <i>region</i> of the screen with the specified <i>color</i>.</p>
<p>This function is called from the <a href="qscreen.html#exposeRegion">exposeRegion</a>() function; it is not intended to be called explicitly.</p>
<p>Reimplement this function to make use of <a href="qtopiacore-accel.html">accelerated hardware</a>. Note that this function must be reimplemented if the framebuffer format is not supported by <a href="qtopiacore.html">Qtopia Core</a> (See the <a href="qtopiacore-displaymanagement.html">Display Management</a> documentation for more details).</p>
<p>See also <a href="qscreen.html#exposeRegion">exposeRegion</a>(), <a href="qscreen.html#blit">blit</a>(), and <a href="qscreen.html#blank">blank</a>().</p>
<h3 class="fn"><a name="subScreenIndexAt"></a>int QScreen::subScreenIndexAt ( const <a href="qpoint.html">QPoint</a> &amp; <i>position</i> ) const</h3>
<p>Returns the index of the subscreen at the given <i>position</i>; returns -1 if no screen is found.</p>
<p>The index identifies the subscreen in the list of pointers returned by the <a href="qscreen.html#subScreens">subScreens</a>() function.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qscreen.html#instance">instance</a>() and <a href="qscreen.html#subScreens">subScreens</a>().</p>
<h3 class="fn"><a name="subScreens"></a><a href="qlist.html">QList</a>&lt;QScreen *&gt; QScreen::subScreens () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns a list of this screen's subscreens. Use the <a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a>() function to retrieve the index of a screen at a given position.</p>
<p>Note that if <i>this</i> screen consists of several subscreens, operations to <i>this</i> instance will affect all subscreens by default.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qscreen.html#instance">instance</a>() and <a href="qscreen.html#subScreenIndexAt">subScreenIndexAt</a>().</p>
<h3 class="fn"><a name="supportsDepth"></a>bool QScreen::supportsDepth ( int <i>depth</i> ) const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns true if the screen supports the specified color <i>depth</i>; otherwise returns false.</p>
<p>See also <a href="qscreen.html#clut">clut</a>().</p>
<h3 class="fn"><a name="totalSize"></a>int QScreen::totalSize () const</h3>
<p>Returns the size of the available graphics card memory (including the screen) in bytes.</p>
<p>See also <a href="qscreen.html#onCard">onCard</a>().</p>
<h3 class="fn"><a name="transformOrientation"></a>int QScreen::transformOrientation () const&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Returns the current rotation as an integer value.</p>
<p>Note that the default implementation returns 0; reimplement this function to override this value.</p>
<p>See also <a href="qscreen.html#isTransformed">isTransformed</a>().</p>
<h3 class="fn"><a name="width"></a>int QScreen::width () const</h3>
<p>Returns the logical width of the framebuffer in pixels.</p>
<p>See also <a href="qscreen.html#deviceWidth">deviceWidth</a>(), <a href="qscreen.html#physicalWidth">physicalWidth</a>(), and <a href="qscreen.html#height">height</a>().</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008 <a href="trolltech.html">Trolltech</a></td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.3.5</div></td>
</tr></table></div></address></body>
</html>
