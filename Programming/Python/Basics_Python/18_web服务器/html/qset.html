<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- /fasttmp/mkdist-qt-4.3.5-1211793125/qtopia-core-opensource-src-4.3.5/doc/src/qset.qdoc -->
<head>
  <title>Qt 4.3: QSet Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><a href="http://www.trolltech.com"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></a></td></tr></table><h1 align="center">QSet Class Reference<br /><sup><sup>[<a href="qtcore.html">QtCore</a> module]</sup></sup></h1>
<p>The QSet class is a template class that provides a hash-table-based set. <a href="#details">More...</a></p>
<pre> #include &lt;QSet&gt;</pre><p><b>Note:</b> All the functions in this class are <a href="threads.html#reentrant">reentrant</a>.</p>
<ul>
<li><a href="qset-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>class <b><a href="qset-const-iterator.html">const_iterator</a></b></li>
<li><div class="fn"/>class <b><a href="qset-iterator.html">iterator</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#ConstIterator-typedef">ConstIterator</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#Iterator-typedef">Iterator</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#const_pointer-typedef">const_pointer</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#const_reference-typedef">const_reference</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#difference_type-typedef">difference_type</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#key_type-typedef">key_type</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#pointer-typedef">pointer</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#reference-typedef">reference</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#size_type-typedef">size_type</a></b></li>
<li><div class="fn"/>typedef <b><a href="qset.html#value_type-typedef">value_type</a></b></li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qset.html#QSet">QSet</a></b> ()</li>
<li><div class="fn"/><b><a href="qset.html#QSet-2">QSet</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#begin">begin</a></b> () const</li>
<li><div class="fn"/>iterator <b><a href="qset.html#begin-2">begin</a></b> ()</li>
<li><div class="fn"/>int <b><a href="qset.html#capacity">capacity</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qset.html#clear">clear</a></b> ()</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#constBegin">constBegin</a></b> () const</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#constEnd">constEnd</a></b> () const</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#constFind">constFind</a></b> ( const T &amp; <i>value</i> ) const</li>
<li><div class="fn"/>bool <b><a href="qset.html#contains">contains</a></b> ( const T &amp; <i>value</i> ) const</li>
<li><div class="fn"/>int <b><a href="qset.html#count">count</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qset.html#empty">empty</a></b> () const</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#end">end</a></b> () const</li>
<li><div class="fn"/>iterator <b><a href="qset.html#end-2">end</a></b> ()</li>
<li><div class="fn"/>iterator <b><a href="qset.html#erase">erase</a></b> ( iterator <i>pos</i> )</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#find">find</a></b> ( const T &amp; <i>value</i> ) const</li>
<li><div class="fn"/>iterator <b><a href="qset.html#find-2">find</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>const_iterator <b><a href="qset.html#insert">insert</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#intersect">intersect</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>bool <b><a href="qset.html#isEmpty">isEmpty</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qset.html#remove">remove</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>void <b><a href="qset.html#reserve">reserve</a></b> ( int <i>size</i> )</li>
<li><div class="fn"/>int <b><a href="qset.html#size">size</a></b> () const</li>
<li><div class="fn"/>void <b><a href="qset.html#squeeze">squeeze</a></b> ()</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#subtract">subtract</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>QList&lt;T&gt; <b><a href="qset.html#toList">toList</a></b> () const</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#unite">unite</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>QList&lt;T&gt; <b><a href="qset.html#values">values</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qset.html#operator-not-eq">operator!=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</li>
<li><div class="fn"/>QSet&lt;T&gt; <b><a href="qset.html#operator-and">operator&amp;</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-and-eq">operator&amp;=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-and-eq-2">operator&amp;=</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; <b><a href="qset.html#operator-2b">operator+</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-2b-eq">operator+=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-2b-eq-2">operator+=</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; <b><a href="qset.html#operator-">operator-</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator--eq">operator-=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator--eq-2">operator-=</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-lt-lt">operator&lt;&lt;</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-eq">operator=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>bool <b><a href="qset.html#operator-eq-eq">operator==</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</li>
<li><div class="fn"/>QSet&lt;T&gt; <b><a href="qset.html#operator-7c">operator|</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-7c-eq">operator|=</a></b> ( const QSet&lt;T&gt; &amp; <i>other</i> )</li>
<li><div class="fn"/>QSet&lt;T&gt; &amp; <b><a href="qset.html#operator-7c-eq-2">operator|=</a></b> ( const T &amp; <i>value</i> )</li>
</ul>
<a name="static-public-members"></a>
<h3>Static Public Members</h3>
<ul>
<li><div class="fn"/>QSet&lt;T&gt; <b><a href="qset.html#fromList">fromList</a></b> ( const QList&lt;T&gt; &amp; <i>list</i> )</li>
</ul>
<a name="related-non-members"></a>
<h3>Related Non-Members</h3>
<ul>
<li><div class="fn"/>QDataStream &amp; <b><a href="qset.html#operator-lt-lt-9">operator&lt;&lt;</a></b> ( QDataStream &amp; <i>out</i>, const QSet&lt;T&gt; &amp; <i>set</i> )</li>
<li><div class="fn"/>QDataStream &amp; <b><a href="qset.html#operator-gt-gt-9">operator&gt;&gt;</a></b> ( QDataStream &amp; <i>in</i>, QSet&lt;T&gt; &amp; <i>set</i> )</li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QSet class is a template class that provides a hash-table-based set.</p>
<p>QSet&lt;T&gt; is one of Qt's generic <a href="containers.html#container-classes">container classes</a>. It stores values in an unspecified order and provides very fast lookup of the values. Internally, QSet&lt;T&gt; is implemented as a <a href="qhash.html">QHash</a>.</p>
<p>Here's an example QSet with <a href="qstring.html">QString</a> values:</p>
<pre> QSet&lt;QString&gt; set;</pre>
<p>To insert a value into the set, use <a href="qset.html#insert">insert</a>():</p>
<pre> set.insert(&quot;one&quot;);
 set.insert(&quot;three&quot;);
 set.insert(&quot;seven&quot;);</pre>
<p>Another way to insert items into the set is to use operator&lt;&lt;():</p>
<pre> set &lt;&lt; &quot;twelve&quot; &lt;&lt; &quot;fifteen&quot; &lt;&lt; &quot;nineteen&quot;;</pre>
<p>To test whether an item belongs to the set or not, use <a href="qset.html#contains">contains</a>():</p>
<pre> if (!set.contains(&quot;ninety-nine&quot;))
     ...</pre>
<p>If you want to navigate through all the values stored in a QSet, you can use an iterator. QSet supports both <a href="containers.html#java-style-iterators">Java-style iterators</a> (<a href="qsetiterator.html">QSetIterator</a> and <a href="qmutablesetiterator.html">QMutableSetIterator</a>) and <a href="containers.html#stl-style-iterators">STL-style iterators</a> (<a href="qset-iterator.html">QSet::iterator</a> and <a href="qset-const-iterator.html">QSet::const_iterator</a>). Here's how to iterate over a QSet&lt;<a href="qwidget.html">QWidget</a> *&gt; using a Java-style iterator:</p>
<pre> QSetIterator&lt;QWidget *&gt; i(set);
 while (i.hasNext())
     qDebug() &lt;&lt; i.next();</pre>
<p>Here's the same code, but using an STL-style iterator:</p>
<pre> QSet&lt;QWidget *&gt;::const_iterator i = set.constBegin();
 while (i != set.constEnd()) {
     qDebug() &lt;&lt; *i;
     ++i;
 }</pre>
<p>QSet is unordered, so an iterator's sequence cannot be assumed to be predictable. If ordering by key is required, use a <a href="qmap.html">QMap</a>.</p>
<p>To navigate through a QSet, you can also use <a href="containers.html#foreach">foreach</a>:</p>
<pre> QSet&lt;QString&gt; set;
 ...
 foreach (QString value, set)
     qDebug() &lt;&lt; value;</pre>
<p>Items can be removed from the set using <a href="qset.html#remove">remove</a>(). There's also a <a href="qset.html#clear">clear</a>() function that removes all items.</p>
<p>QSet's value data type must be an <a href="containers.html#assignable-data-types">assignable data type</a>. You cannot, for example, store a <a href="qwidget.html">QWidget</a> as a value; instead, store a <a href="qwidget.html">QWidget</a> *. In addition, the type must provide <tt>operator==()</tt>, and there must also be a global <a href="qhash.html#qHashx">qHash</a>() function that returns a hash value for an argument of the key's type. See the <a href="qhash.html">QHash</a> documentation for a list of types supported by <a href="qhash.html#qHashx">qHash</a>().</p>
<p>Internally, QSet uses a hash table to perform lookups. The hash table automatically grows and shrinks to provide fast lookups without wasting too much memory. You can still control the size of the hash table by calling <a href="qset.html#reserve">reserve</a>() if you already know approximately how many elements the QSet will contain, but this isn't necessary to obtain good performance. You can also call <a href="qset.html#capacity">capacity</a>() to retrieve the hash table's size.</p>
<p>See also <a href="qsetiterator.html">QSetIterator</a>, <a href="qmutablesetiterator.html">QMutableSetIterator</a>, <a href="qhash.html">QHash</a>, and <a href="qmap.html">QMap</a>.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="ConstIterator-typedef"></a>typedef QSet::ConstIterator</h3>
<p>Qt-style synonym for <a href="qset-const-iterator.html">QSet::const_iterator</a>.</p>
<h3 class="fn"><a name="Iterator-typedef"></a>typedef QSet::Iterator</h3>
<p>Qt-style synonym for <a href="qset-iterator.html">QSet::iterator</a>.</p>
<p>This typedef was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="const_pointer-typedef"></a>typedef QSet::const_pointer</h3>
<p>Typedef for const T *. Provided for STL compatibility.</p>
<h3 class="fn"><a name="const_reference-typedef"></a>typedef QSet::const_reference</h3>
<p>Typedef for const T &amp;. Provided for STL compatibility.</p>
<h3 class="fn"><a name="difference_type-typedef"></a>typedef QSet::difference_type</h3>
<p>Typedef for const ptrdiff_t. Provided for STL compatibility.</p>
<h3 class="fn"><a name="key_type-typedef"></a>typedef QSet::key_type</h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<h3 class="fn"><a name="pointer-typedef"></a>typedef QSet::pointer</h3>
<p>Typedef for T *. Provided for STL compatibility.</p>
<h3 class="fn"><a name="reference-typedef"></a>typedef QSet::reference</h3>
<p>Typedef for T &amp;. Provided for STL compatibility.</p>
<h3 class="fn"><a name="size_type-typedef"></a>typedef QSet::size_type</h3>
<p>Typedef for int. Provided for STL compatibility.</p>
<h3 class="fn"><a name="value_type-typedef"></a>typedef QSet::value_type</h3>
<p>Typedef for T. Provided for STL compatibility.</p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="QSet"></a>QSet::QSet ()</h3>
<p>Constructs an empty set.</p>
<p>See also <a href="qset.html#clear">clear</a>().</p>
<h3 class="fn"><a name="QSet-2"></a>QSet::QSet ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Constructs a copy of <i>other</i>.</p>
<p>This operation occurs in <a href="containers.html#constant-time">constant time</a>, because <a href="qset.html">QSet</a> is <a href="shared.html#implicitly-shared">implicitly shared</a>. This makes returning a <a href="qset.html">QSet</a> from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and this takes <a href="containers.html#linear-time">linear time</a>.</p>
<p>See also <a href="qset.html#operator-eq">operator=</a>().</p>
<h3 class="fn"><a name="begin"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::begin () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the set.</p>
<p>See also <a href="qset.html#constBegin">constBegin</a>() and <a href="qset.html#end">end</a>().</p>
<h3 class="fn"><a name="begin-2"></a><a href="qset-iterator.html">iterator</a> QSet::begin ()</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the set.</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="capacity"></a>int QSet::capacity () const</h3>
<p>Returns the number of buckets in the <a href="qset.html">QSet</a>'s internal hash table.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html">QSet</a>'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the set, call <a href="qset.html#size">size</a>().</p>
<p>See also <a href="qset.html#reserve">reserve</a>() and <a href="qset.html#squeeze">squeeze</a>().</p>
<h3 class="fn"><a name="clear"></a>void QSet::clear ()</h3>
<p>Removes all elements from the set.</p>
<p>See also <a href="qset.html#remove">remove</a>().</p>
<h3 class="fn"><a name="constBegin"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::constBegin () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the first item in the set.</p>
<p>See also <a href="qset.html#begin">begin</a>() and <a href="qset.html#constEnd">constEnd</a>().</p>
<h3 class="fn"><a name="constEnd"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::constEnd () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p>See also <a href="qset.html#constBegin">constBegin</a>() and <a href="qset.html#end">end</a>().</p>
<h3 class="fn"><a name="constFind"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::constFind ( const T &amp; <i>value</i> ) const</h3>
<p>Returns a const iterator pointing to the item <i>value</i> in the set.</p>
<p>If the set contains no item <i>value</i>, the function returns <a href="qset.html#constEnd">constEnd</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qset.html#find">find</a>() and <a href="qset.html#contains">contains</a>().</p>
<h3 class="fn"><a name="contains"></a>bool QSet::contains ( const T &amp; <i>value</i> ) const</h3>
<p>Returns true if the set contains item <i>value</i>; otherwise returns false.</p>
<p>See also <a href="qset.html#insert">insert</a>(), <a href="qset.html#remove">remove</a>(), and <a href="qset.html#find">find</a>().</p>
<h3 class="fn"><a name="count"></a>int QSet::count () const</h3>
<p>Same as <a href="qset.html#size">size</a>().</p>
<h3 class="fn"><a name="empty"></a>bool QSet::empty () const</h3>
<p>Returns true if the set is empty. This function is provided for STL compatibility. It is equivalent to <a href="qset.html#isEmpty">isEmpty</a>().</p>
<h3 class="fn"><a name="end"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::end () const</h3>
<p>Returns a const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p>See also <a href="qset.html#constEnd">constEnd</a>() and <a href="qset.html#begin">begin</a>().</p>
<h3 class="fn"><a name="end-2"></a><a href="qset-iterator.html">iterator</a> QSet::end ()</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Returns a non-const <a href="containers.html#stl-style-iterators">STL-style iterator</a> pointing to the imaginary item after the last item in the set.</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="erase"></a><a href="qset-iterator.html">iterator</a> QSet::erase ( <a href="qset-iterator.html">iterator</a> <i>pos</i> )</h3>
<p>Removes the item associated with the iterator <i>pos</i> from the set, and returns an iterator to the next item in the set.</p>
<p>Unlike <a href="qset.html#remove">remove</a>(), this function never causes <a href="qset.html">QSet</a> to rehash its internal data structure. This means that it can safely be called while iterating, and won't affect the order of items in the set.</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qset.html#remove">remove</a>() and <a href="qset.html#find">find</a>().</p>
<h3 class="fn"><a name="find"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::find ( const T &amp; <i>value</i> ) const</h3>
<p>Returns a const iterator pointing to the item <i>value</i> in the set.</p>
<p>If the set contains no item <i>value</i>, the function returns <a href="qset.html#constEnd">constEnd</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<p>See also <a href="qset.html#constFind">constFind</a>() and <a href="qset.html#contains">contains</a>().</p>
<h3 class="fn"><a name="find-2"></a><a href="qset-iterator.html">iterator</a> QSet::find ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Returns a non-const iterator pointing to the item <i>value</i> in the set.</p>
<p>If the set contains no item <i>value</i>, the function returns <a href="qset.html#end">end</a>().</p>
<p>This function was introduced in Qt 4.2.</p>
<h3 class="fn"><a name="fromList"></a>QSet&lt;T&gt; QSet::fromList ( const <a href="qlist.html">QList</a>&lt;T&gt; &amp; <i>list</i> )&nbsp;&nbsp;<tt> [static]</tt></h3>
<p>Returns a <a href="qset.html">QSet</a> object with the data contained in <i>list</i>. Since <a href="qset.html">QSet</a> doesn't allow duplicates, the resulting <a href="qset.html">QSet</a> might be smaller than the original <i>list</i> was.</p>
<p>Example:</p>
<pre> QStringList list;
 list &lt;&lt; &quot;Julia&quot; &lt;&lt; &quot;Mike&quot; &lt;&lt; &quot;Mike&quot; &lt;&lt; &quot;Julia&quot; &lt;&lt; &quot;Julia&quot;;

 QSet&lt;QString&gt; set = QSet&lt;QString&gt;::fromList(list);
 set.contains(&quot;Julia&quot;);  <span class="comment">//</span> returns true
 set.contains(&quot;Mike&quot;);   <span class="comment">//</span> returns true
 set.size();             <span class="comment">//</span> returns 2</pre>
<p>See also <a href="qset.html#toList">toList</a>() and <a href="qlist.html#toSet">QList::toSet</a>().</p>
<h3 class="fn"><a name="insert"></a><a href="qset-const-iterator.html">const_iterator</a> QSet::insert ( const T &amp; <i>value</i> )</h3>
<p>Inserts a new item <i>value</i>. If <i>value</i> already exists in the set, nothing happens.</p>
<p>See also <a href="qset.html#operator-lt-lt">operator&lt;&lt;</a>(), <a href="qset.html#remove">remove</a>(), and <a href="qset.html#contains">contains</a>().</p>
<h3 class="fn"><a name="intersect"></a>QSet&lt;T&gt; &amp; QSet::intersect ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Removes any items in this set that don't exist in the <i>other</i> set.</p>
<p>See also <a href="qset.html#operator-and-eq">operator&amp;=</a>(), <a href="qset.html#unite">unite</a>(), and <a href="qset.html#subtract">subtract</a>().</p>
<h3 class="fn"><a name="isEmpty"></a>bool QSet::isEmpty () const</h3>
<p>Returns true if the set contains no elements; otherwise returns false.</p>
<p>See also <a href="qset.html#size">size</a>().</p>
<h3 class="fn"><a name="remove"></a>bool QSet::remove ( const T &amp; <i>value</i> )</h3>
<p>Removes any occurrence of item <i>value</i> from the set. Returns true if an item was actually removed; otherwise returns false.</p>
<p>See also <a href="qset.html#contains">contains</a>() and <a href="qset.html#insert">insert</a>().</p>
<h3 class="fn"><a name="reserve"></a>void QSet::reserve ( int <i>size</i> )</h3>
<p>Ensures that the <a href="qset.html">QSet</a>'s internal hash table consists of at least <i>size</i> buckets.</p>
<p>This function is useful for code that needs to build a huge set and wants to avoid repeated reallocation. For example:</p>
<pre> QSet&lt;QString&gt; set;
 set.reserve(20000);
 for (int i = 0; i &lt; 20000; ++i)
     set.insert(values[i]);</pre>
<p>Ideally, <i>size</i> should be slightly more than the maximum number of elements expected in the set. <i>size</i> doesn't have to be prime, because <a href="qset.html">QSet</a> will use a prime number internally anyway. If <i>size</i> is an underestimate, the worst that will happen is that the <a href="qset.html">QSet</a> will be a bit slower.</p>
<p>In general, you will rarely ever need to call this function. <a href="qset.html">QSet</a>'s internal hash table automatically shrinks or grows to provide good performance without wasting too much memory.</p>
<p>See also <a href="qset.html#squeeze">squeeze</a>() and <a href="qset.html#capacity">capacity</a>().</p>
<h3 class="fn"><a name="size"></a>int QSet::size () const</h3>
<p>Returns the number of items in the set.</p>
<p>See also <a href="qset.html#isEmpty">isEmpty</a>() and <a href="qset.html#count">count</a>().</p>
<h3 class="fn"><a name="squeeze"></a>void QSet::squeeze ()</h3>
<p>Reduces the size of the <a href="qset.html">QSet</a>'s internal hash table to save memory.</p>
<p>The sole purpose of this function is to provide a means of fine tuning <a href="qset.html">QSet</a>'s memory usage. In general, you will rarely ever need to call this function.</p>
<p>See also <a href="qset.html#reserve">reserve</a>() and <a href="qset.html#capacity">capacity</a>().</p>
<h3 class="fn"><a name="subtract"></a>QSet&lt;T&gt; &amp; QSet::subtract ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Removes all the items in the <i>other</i> set from this set.</p>
<p>See also <a href="qset.html#operator--eq">operator-=</a>(), <a href="qset.html#unite">unite</a>(), and <a href="qset.html#intersect">intersect</a>().</p>
<h3 class="fn"><a name="toList"></a><a href="qlist.html">QList</a>&lt;T&gt; QSet::toList () const</h3>
<p>Returns a <a href="qlist.html">QList</a> object with the data contained in this <a href="qset.html">QSet</a>. The order of the elements in the <a href="qlist.html">QList</a> is undefined.</p>
<p>Example:</p>
<pre> QSet&lt;QString&gt; set;
 set &lt;&lt; &quot;red&quot; &lt;&lt; &quot;green&quot; &lt;&lt; &quot;blue&quot; &lt;&lt; ... &lt;&lt; &quot;black&quot;;

 QList&lt;QString&gt; list = set.toList();
 qSort(list);</pre>
<p>See also <a href="qset.html#fromList">fromList</a>(), <a href="qlist.html#fromSet">QList::fromSet</a>(), and <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<h3 class="fn"><a name="unite"></a>QSet&lt;T&gt; &amp; QSet::unite ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Inserts all the items in the <i>other</i> set into this set.</p>
<p>See also <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#intersect">intersect</a>(), and <a href="qset.html#subtract">subtract</a>().</p>
<h3 class="fn"><a name="values"></a><a href="qlist.html">QList</a>&lt;T&gt; QSet::values () const</h3>
<p>Returns a <a href="qlist.html">QList</a> object with the data contained in this <a href="qset.html">QSet</a>. The order of the elements in the <a href="qlist.html">QList</a> is undefined.</p>
<p>This is the same as <a href="qset.html#toList">toList</a>().</p>
<p>See also <a href="qset.html#fromList">fromList</a>(), <a href="qlist.html#fromSet">QList::fromSet</a>(), and <a href="qtalgorithms.html#qSort">qSort</a>().</p>
<h3 class="fn"><a name="operator-not-eq"></a>bool QSet::operator!= ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if <i>other</i> is not equal to this set; otherwise returns false.</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>This function requires the value type to implement <tt>operator==()</tt>.</p>
<p>See also <a href="qset.html#operator-eq-eq">operator==</a>().</p>
<h3 class="fn"><a name="operator-and"></a>QSet&lt;T&gt; QSet::operator&amp; ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns the intersection of this set and <i>other</i>.</p>
<p>See also <a href="qset.html#intersect">intersect</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), <a href="qset.html#operator-7c">operator|</a>(), and <a href="qset.html#operator-">operator-</a>().</p>
<h3 class="fn"><a name="operator-and-eq"></a>QSet&lt;T&gt; &amp; QSet::operator&amp;= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Syntactic sugar for intersect(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-and">operator&amp;</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), and <a href="qset.html#operator--eq">operator-=</a>().</p>
<h3 class="fn"><a name="operator-and-eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator&amp;= ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Syntactic sugar for intersect(<i>other</i>), with <i>other</i> being a set that only contains <i>value</i>.</p>
<h3 class="fn"><a name="operator-2b"></a>QSet&lt;T&gt; QSet::operator+ ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns the union of this set and <i>other</i>.</p>
<p>See also <a href="qset.html#unite">unite</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#operator-and">operator&amp;</a>(), and <a href="qset.html#operator-">operator-</a>().</p>
<h3 class="fn"><a name="operator-2b-eq"></a>QSet&lt;T&gt; &amp; QSet::operator+= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Syntactic sugar for unite(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-7c">operator|</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), and <a href="qset.html#operator--eq">operator-=</a>().</p>
<h3 class="fn"><a name="operator-2b-eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator+= ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Inserts a new item <i>value</i> and returns a reference to this set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#insert">insert</a>().</p>
<h3 class="fn"><a name="operator-"></a>QSet&lt;T&gt; QSet::operator- ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns the set difference of this set with <i>other</i>.</p>
<p>See also <a href="qset.html#subtract">subtract</a>(), <a href="qset.html#operator--eq">operator-=</a>(), <a href="qset.html#operator-7c">operator|</a>(), and <a href="qset.html#operator-and">operator&amp;</a>().</p>
<h3 class="fn"><a name="operator--eq"></a>QSet&lt;T&gt; &amp; QSet::operator-= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Syntactic sugar for subtract(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-">operator-</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), and <a href="qset.html#operator-and-eq">operator&amp;=</a>().</p>
<h3 class="fn"><a name="operator--eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator-= ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Removes any occurrence of item <i>value</i> from the set and returns a reference to this set. If <i>value</i> didn't exist in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#remove">remove</a>().</p>
<h3 class="fn"><a name="operator-lt-lt"></a>QSet&lt;T&gt; &amp; QSet::operator&lt;&lt; ( const T &amp; <i>value</i> )</h3>
<p>Inserts a new item <i>value</i> and returns a reference to this set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#insert">insert</a>().</p>
<h3 class="fn"><a name="operator-eq"></a>QSet&lt;T&gt; &amp; QSet::operator= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Assigns <i>other</i> to this set and returns a reference to this set.</p>
<h3 class="fn"><a name="operator-eq-eq"></a>bool QSet::operator== ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns true if <i>other</i> is equal to this set; otherwise returns false.</p>
<p>Two sets are considered equal if they contain the same elements.</p>
<p>This function requires the value type to implement <tt>operator==()</tt>.</p>
<p>See also <a href="qset.html#operator-not-eq">operator!=</a>().</p>
<h3 class="fn"><a name="operator-7c"></a>QSet&lt;T&gt; QSet::operator| ( const QSet&lt;T&gt; &amp; <i>other</i> ) const</h3>
<p>Returns the union of this set and <i>other</i>.</p>
<p>See also <a href="qset.html#unite">unite</a>(), <a href="qset.html#operator-7c-eq">operator|=</a>(), <a href="qset.html#operator-and">operator&amp;</a>(), and <a href="qset.html#operator-">operator-</a>().</p>
<h3 class="fn"><a name="operator-7c-eq"></a>QSet&lt;T&gt; &amp; QSet::operator|= ( const QSet&lt;T&gt; &amp; <i>other</i> )</h3>
<p>Syntactic sugar for unite(<i>other</i>).</p>
<p>See also <a href="qset.html#operator-7c">operator|</a>(), <a href="qset.html#operator-and-eq">operator&amp;=</a>(), and <a href="qset.html#operator--eq">operator-=</a>().</p>
<h3 class="fn"><a name="operator-7c-eq-2"></a>QSet&lt;T&gt; &amp; QSet::operator|= ( const T &amp; <i>value</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Inserts a new item <i>value</i> and returns a reference to this set. If <i>value</i> already exists in the set, the set is left unchanged.</p>
<p>See also <a href="qset.html#insert">insert</a>().</p>
<hr />
<h2>Related Non-Members</h2>
<h3 class="fn"><a name="operator-lt-lt-9"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&lt;&lt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>out</i>, const QSet&lt;T&gt; &amp; <i>set</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Writes the set <i>set</i> to stream <i>out</i>.</p>
<p>This function requires the value type to implement <tt>operator&lt;&lt;()</tt>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.</p>
<h3 class="fn"><a name="operator-gt-gt-9"></a><a href="qdatastream.html">QDataStream</a> &amp; operator&gt;&gt; ( <a href="qdatastream.html">QDataStream</a> &amp; <i>in</i>, QSet&lt;T&gt; &amp; <i>set</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Reads a set from stream <i>in</i> into <i>set</i>.</p>
<p>This function requires the value type to implement <tt>operator&gt;&gt;()</tt>.</p>
<p>See also <a href="datastreamformat.html">Format of the QDataStream operators</a>.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008 <a href="trolltech.html">Trolltech</a></td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.3.5</div></td>
</tr></table></div></address></body>
</html>
