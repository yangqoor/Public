<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- /fasttmp/mkdist-qt-4.3.5-1211793125/qtopia-core-opensource-src-4.3.5/src/script/qscriptengine.cpp -->
<head>
  <title>Qt 4.3: QScriptEngine Class Reference</title>
  <link href="classic.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td align="left" valign="top" width="32"><a href="http://www.trolltech.com/products/qt"><img src="images/qt-logo.png" align="left" width="32" height="32" border="0" /></a></td>
<td width="1">&nbsp;&nbsp;</td><td class="postheader" valign="center"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; <a href="classes.html"><font color="#004faf">All&nbsp;Classes</font></a>&nbsp;&middot; <a href="mainclasses.html"><font color="#004faf">Main&nbsp;Classes</font></a>&nbsp;&middot; <a href="groups.html"><font color="#004faf">Grouped&nbsp;Classes</font></a>&nbsp;&middot; <a href="modules.html"><font color="#004faf">Modules</font></a>&nbsp;&middot; <a href="functions.html"><font color="#004faf">Functions</font></a></td>
<td align="right" valign="top" width="230"><a href="http://www.trolltech.com"><img src="images/trolltech-logo.png" align="right" width="203" height="32" border="0" /></a></td></tr></table><h1 align="center">QScriptEngine Class Reference<br /><sup><sup>[<a href="qtscript.html">QtScript</a> module]</sup></sup></h1>
<p>The QScriptEngine class provides an environment for evaluating Qt Script code. <a href="#details">More...</a></p>
<pre> #include &lt;QScriptEngine&gt;</pre><p>Inherits <a href="qobject.html">QObject</a>.</p>
<p>This class was introduced in Qt 4.3.</p>
<ul>
<li><a href="qscriptengine-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h3>Public Types</h3>
<ul>
<li><div class="fn"/>typedef <b><a href="qscriptengine.html#FunctionSignature-typedef">FunctionSignature</a></b></li>
<li><div class="fn"/>enum <b><a href="qscriptengine.html#QObjectWrapOption-enum">QObjectWrapOption</a></b> { ExcludeChildObjects, ExcludeSuperClassMethods, ExcludeSuperClassProperties, AutoCreateDynamicProperties }</li>
<li><div class="fn"/>flags <b><a href="qscriptengine.html#QObjectWrapOption-enum">QObjectWrapOptions</a></b></li>
<li><div class="fn"/>enum <b><a href="qscriptengine.html#ValueOwnership-enum">ValueOwnership</a></b> { QtOwnership, ScriptOwnership, AutoOwnership }</li>
</ul>
<a name="public-functions"></a>
<h3>Public Functions</h3>
<ul>
<li><div class="fn"/><b><a href="qscriptengine.html#QScriptEngine">QScriptEngine</a></b> ()</li>
<li><div class="fn"/><b><a href="qscriptengine.html#QScriptEngine-2">QScriptEngine</a></b> ( QObject * <i>parent</i> )</li>
<li><div class="fn"/>virtual <b><a href="qscriptengine.html#dtor.QScriptEngine">~QScriptEngine</a></b> ()</li>
<li><div class="fn"/>bool <b><a href="qscriptengine.html#canEvaluate">canEvaluate</a></b> ( const QString &amp; <i>program</i> ) const</li>
<li><div class="fn"/>void <b><a href="qscriptengine.html#collectGarbage">collectGarbage</a></b> ()</li>
<li><div class="fn"/>QScriptContext * <b><a href="qscriptengine.html#currentContext">currentContext</a></b> () const</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#defaultPrototype">defaultPrototype</a></b> ( int <i>metaTypeId</i> ) const</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#evaluate">evaluate</a></b> ( const QString &amp; <i>program</i>, const QString &amp; <i>fileName</i> = QString(), int <i>lineNumber</i> = 1 )</li>
<li><div class="fn"/>T <b><a href="qscriptengine.html#fromScriptValue">fromScriptValue</a></b> ( const QScriptValue &amp; <i>value</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#globalObject">globalObject</a></b> () const</li>
<li><div class="fn"/>bool <b><a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a></b> () const</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#importExtension">importExtension</a></b> ( const QString &amp; <i>extension</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newArray">newArray</a></b> ( uint <i>length</i> = 0 )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newDate">newDate</a></b> ( qsreal <i>value</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newDate-2">newDate</a></b> ( const QDateTime &amp; <i>value</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newFunction">newFunction</a></b> ( FunctionSignature <i>fun</i>, int <i>length</i> = 0 )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newFunction-2">newFunction</a></b> ( FunctionSignature <i>fun</i>, const QScriptValue &amp; <i>prototype</i>, int <i>length</i> = 0 )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newObject">newObject</a></b> ()</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newQMetaObject">newQMetaObject</a></b> ( const QMetaObject * <i>metaObject</i>, const QScriptValue &amp; <i>ctor</i> = QScriptValue() )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newQObject">newQObject</a></b> ( QObject * <i>object</i>, ValueOwnership <i>ownership</i> = QtOwnership, const QObjectWrapOptions &amp; <i>options</i> = 0 )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newRegExp">newRegExp</a></b> ( const QRegExp &amp; <i>regexp</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newRegExp-2">newRegExp</a></b> ( const QString &amp; <i>pattern</i>, const QString &amp; <i>flags</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#newVariant">newVariant</a></b> ( const QVariant &amp; <i>value</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#nullValue">nullValue</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qscriptengine.html#popContext">popContext</a></b> ()</li>
<li><div class="fn"/>int <b><a href="qscriptengine.html#processEventsInterval">processEventsInterval</a></b> () const</li>
<li><div class="fn"/>QScriptContext * <b><a href="qscriptengine.html#pushContext">pushContext</a></b> ()</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#scriptValueFromQMetaObject">scriptValueFromQMetaObject</a></b> ()</li>
<li><div class="fn"/>void <b><a href="qscriptengine.html#setDefaultPrototype">setDefaultPrototype</a></b> ( int <i>metaTypeId</i>, const QScriptValue &amp; <i>prototype</i> )</li>
<li><div class="fn"/>void <b><a href="qscriptengine.html#setProcessEventsInterval">setProcessEventsInterval</a></b> ( int <i>interval</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#toScriptValue">toScriptValue</a></b> ( const T &amp; <i>value</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#uncaughtException">uncaughtException</a></b> () const</li>
<li><div class="fn"/>QStringList <b><a href="qscriptengine.html#uncaughtExceptionBacktrace">uncaughtExceptionBacktrace</a></b> () const</li>
<li><div class="fn"/>int <b><a href="qscriptengine.html#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</a></b> () const</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#undefinedValue">undefinedValue</a></b> ()</li>
</ul>
<ul>
<li><div class="fn"/>29 public functions inherited from <a href="qobject.html#public-functions">QObject</a></li>
</ul>
<a name="related-non-members"></a>
<h3>Related Non-Members</h3>
<ul>
<li><div class="fn"/>typedef <b><a href="qscriptengine.html#FunctionSignature-typedef">FunctionSignature</a></b></li>
<li><div class="fn"/>int <b><a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a></b> ( QScriptEngine * <i>engine</i>, QScriptValue(* ) ( QScriptEngine *, const T &amp; t ) <i>toScriptValue</i>, void(* ) ( const QScriptValue &amp;, T &amp; t ) <i>fromScriptValue</i>, const QScriptValue &amp; <i>prototype</i> = QScriptValue() )</li>
<li><div class="fn"/>int <b><a href="qscriptengine.html#qScriptRegisterSequenceMetaType">qScriptRegisterSequenceMetaType</a></b> ( QScriptEngine * <i>engine</i>, const QScriptValue &amp; <i>prototype</i> = QScriptValue() )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#qScriptValueFromQMetaObject">qScriptValueFromQMetaObject</a></b> ( QScriptEngine * <i>engine</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#qScriptValueFromSequence">qScriptValueFromSequence</a></b> ( QScriptEngine * <i>engine</i>, const Container &amp; <i>container</i> )</li>
<li><div class="fn"/>QScriptValue <b><a href="qscriptengine.html#qScriptValueFromValue">qScriptValueFromValue</a></b> ( QScriptEngine * <i>engine</i>, const T &amp; <i>value</i> )</li>
<li><div class="fn"/>void <b><a href="qscriptengine.html#qScriptValueToSequence">qScriptValueToSequence</a></b> ( const QScriptValue &amp; <i>value</i>, Container &amp; <i>container</i> )</li>
<li><div class="fn"/>T <b><a href="qscriptengine.html#qScriptValueToValue">qScriptValueToValue</a></b> ( const QScriptValue &amp; <i>value</i> )</li>
</ul>
<a name="macros"></a>
<h3>Macros</h3>
<ul>
<li><div class="fn"/><b><a href="qscriptengine.html#Q_SCRIPT_DECLARE_QMETAOBJECT">Q_SCRIPT_DECLARE_QMETAOBJECT</a></b> (  <i>QMetaObject</i>,  <i>ArgType</i> )</li>
</ul>
<h3>Additional Inherited Members</h3>
<ul>
<li><div class="fn"/>1 property inherited from <a href="qobject.html#properties">QObject</a></li>
<li><div class="fn"/>1 public slot inherited from <a href="qobject.html#public-slots">QObject</a></li>
<li><div class="fn"/>1 signal inherited from <a href="qobject.html#signals">QObject</a></li>
<li><div class="fn"/>5 static public members inherited from <a href="qobject.html#static-public-members">QObject</a></li>
<li><div class="fn"/>7 protected functions inherited from <a href="qobject.html#protected-functions">QObject</a></li>
</ul>
<a name="details"></a>
<hr />
<h2>Detailed Description</h2>
<p>The QScriptEngine class provides an environment for evaluating Qt Script code.</p>
<p>See the <a href="qtscript.html">QtScript</a> documentation for information about the Qt Script language, and how to get started with scripting your C++ application.</p>
<p>Use <a href="qscriptengine.html#evaluate">evaluate</a>() to evaluate script code.</p>
<pre> QScriptEngine myEngine;
 QScriptValue three = myEngine.evaluate(&quot;1 + 2&quot;);</pre>
<p><a href="qscriptengine.html#evaluate">evaluate</a>() can throw a script exception (e.g&#x2e; due to a syntax error); in that case, the return value is the value that was thrown (typically an <tt>Error</tt> object). You can check whether the evaluation caused an exception by calling <a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a>(). In that case, you can call toString() on the error object to obtain an error message. The current uncaught exception is also available through <a href="qscriptengine.html#uncaughtException">uncaughtException</a>(). You can obtain a human-readable backtrace of the exception with <a href="qscriptengine.html#uncaughtExceptionBacktrace">uncaughtExceptionBacktrace</a>().</p>
<pre> QScriptValue result = myEngine.evaluate(...);
 if (myEngine.hasUncaughtException()) {
     int line = myEngine.uncaughtExceptionLineNumber();
     qDebug() &lt;&lt; &quot;uncaught exception at line&quot; &lt;&lt; line &lt;&lt; &quot;:&quot; &lt;&lt; result.toString();
 }</pre>
<p>When handling possibly incomplete input, the <a href="qscriptengine.html#canEvaluate">canEvaluate</a>() function can be used to determine whether code can usefully be passed to <a href="qscriptengine.html#evaluate">evaluate</a>(). This can be useful when implementing tools that allow code to be written incrementally, such as command line interpreters.</p>
<p>Use <a href="qscriptengine.html#newObject">newObject</a>() to create a standard Qt Script object. You can use the object-specific functionality in <a href="qscriptvalue.html">QScriptValue</a> to manipulate the script object (e.g&#x2e; <a href="qscriptvalue.html#setProperty">QScriptValue::setProperty</a>()). Use <a href="qscriptengine.html#newArray">newArray</a>() to create a Qt script array object. Use <a href="qscriptengine.html#newDate">newDate</a>() to create a <tt>Date</tt> object, and <a href="qscriptengine.html#newRegExp">newRegExp</a>() to create a <tt>RegExp</tt> object. Use <a href="qscriptengine.html#newVariant">newVariant</a>() to wrap a <a href="qvariant.html">QVariant</a>.</p>
<p>Use <a href="qscriptengine.html#newQObject">newQObject</a>() to wrap a <a href="qobject.html">QObject</a> (or subclass) pointer, and <a href="qscriptengine.html#newQMetaObject">newQMetaObject</a>() to wrap a <a href="qmetaobject.html">QMetaObject</a>. When wrapping a <a href="qobject.html">QObject</a> pointer with <a href="qscriptengine.html#newQObject">newQObject</a>(), properties, children and signals and slots of the <a href="qobject.html">QObject</a> will then become available to script code as properties of the created Qt Script object. No binding code is needed because it is done dynamically using the Qt meta object system. See the <a href="qtscript.html">QtScript</a> documentation for more information.</p>
<p>Use <a href="qscriptengine.html#newFunction">newFunction</a>() to wrap native (C++) functions, including constructors for your own custom types.</p>
<p>Use <a href="qscriptengine.html#importExtension">importExtension</a>() to import plugin-based extensions into the engine.</p>
<p>Use <a href="qscriptengine.html#globalObject">globalObject</a>() to access the unique <b>Global Object</b> associated with the script engine. Properties of the Global Object are accessible from any script code. Typically, you set properties in the engine's Global Object to make your own extensions available to scripts. Here is an example of how to expose a number value through the Global Object:</p>
<pre> QScriptValue myNumber = QScriptValue(&amp;myEngine, 123);
 myEngine.globalObject().setProperty(&quot;myNumber&quot;, myNumber);
 ...
 QScriptValue myNumberPlusOne = myEngine.evaluate(&quot;myNumber + 1&quot;);</pre>
<p>In addition to exposing plain data, you can also write C++ functions that can be invoked from script code. Such functions must have the signature <a href="qscriptengine.html#FunctionSignature-typedef">QScriptEngine::FunctionSignature</a>. You may then pass the function as argument to <a href="qscriptengine.html#newFunction">newFunction</a>(). Here is an example of a function that returns the sum of its first two arguments:</p>
<pre> QScriptValue myAdd(QScriptContext *context, QScriptEngine *engine)
 {
    QScriptValue a = context-&gt;argument(0);
    QScriptValue b = context-&gt;argument(1);
    return QScriptValue(engine, a.toNumber() + b.toNumber());
 }</pre>
<p>To expose this function to script code, you can set it as a property of the Global Object:</p>
<pre> QScriptValue fun = myEngine.newFunction(myAdd);
 myEngine.globalObject().setProperty(&quot;myAdd&quot;, fun);</pre>
<p>Once this is done, script code can call your function in the exact same manner as a &quot;normal&quot; script function:</p>
<pre> QScriptValue result = myEngine.evaluate(&quot;myAdd(myNumber, 1)&quot;);</pre>
<p>You can define shared script functionality for a custom C++ type by creating your own default prototype object and setting it with <a href="qscriptengine.html#setDefaultPrototype">setDefaultPrototype</a>(); see also <a href="qscriptable.html">QScriptable</a>.</p>
<p>Use <a href="qscriptengine.html#fromScriptValue">fromScriptValue</a>() to cast from a <a href="qscriptvalue.html">QScriptValue</a> to another type, and <a href="qscriptengine.html#toScriptValue">toScriptValue</a>() to create a <a href="qscriptvalue.html">QScriptValue</a> from another value. You can specify how the conversion of C++ types is to be performed with <a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a>() and <a href="qscriptengine.html#qScriptRegisterSequenceMetaType">qScriptRegisterSequenceMetaType</a>().</p>
<p>See also <a href="qscriptvalue.html">QScriptValue</a> and <a href="qscriptcontext.html">QScriptContext</a>.</p>
<hr />
<h2>Member Type Documentation</h2>
<h3 class="fn"><a name="FunctionSignature-typedef"></a>typedef QScriptEngine::FunctionSignature</h3>
<p>The function signature <tt>QScriptValue f(QScriptContext *, QScriptEngine *)</tt>.</p>
<p>A function with such a signature can be passed to <a href="qscriptengine.html#newFunction">QScriptEngine::newFunction</a>() to wrap the function.</p>
<h3 class="flags"><a name="QObjectWrapOption-enum"></a>enum QScriptEngine::QObjectWrapOption<br />flags QScriptEngine::QObjectWrapOptions</h3>
<p>These flags specify options when wrapping a <a href="qobject.html">QObject</a> pointer with <a href="qscriptengine.html#newQObject">newQObject</a>().</p>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QScriptEngine::ExcludeChildObjects</tt></td><td align="center" valign="top"><tt>0x0001</tt></td><td valign="top">The script object will not expose child objects as properties.</td></tr>
<tr><td valign="top"><tt>QScriptEngine::ExcludeSuperClassMethods</tt></td><td align="center" valign="top"><tt>0x0002</tt></td><td valign="top">The script object will not expose signals and slots inherited from the superclass.</td></tr>
<tr><td valign="top"><tt>QScriptEngine::ExcludeSuperClassProperties</tt></td><td align="center" valign="top"><tt>0x0004</tt></td><td valign="top">The script object will not expose properties inherited from the superclass.</td></tr>
<tr><td valign="top"><tt>QScriptEngine::AutoCreateDynamicProperties</tt></td><td align="center" valign="top"><tt>0x0100</tt></td><td valign="top">Properties that don't already exist in the <a href="qobject.html">QObject</a> will be created as dynamic properties of that object, rather than as properties of the script object.</td></tr>
</table></p>
<p>The QObjectWrapOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;QObjectWrapOption&gt;. It stores an OR combination of QObjectWrapOption values.</p>
<h3 class="fn"><a name="ValueOwnership-enum"></a>enum QScriptEngine::ValueOwnership</h3>
<p>This enum specifies the ownership when wrapping a C++ value, e.g&#x2e; by using <a href="qscriptengine.html#newQObject">newQObject</a>().</p>
<p><table border="1" cellpadding="2" cellspacing="1" width="100%">
<tr><th width="25%">Constant</th><th width="15%">Value</th><th width="60%">Description</th></tr>
<tr><td valign="top"><tt>QScriptEngine::QtOwnership</tt></td><td align="center" valign="top"><tt>0</tt></td><td valign="top">The standard Qt ownership rules apply, i.e&#x2e; the associated object will never be explicitly deleted by the script engine. This is the default. (<a href="qobject.html">QObject</a> ownership is explained in <a href="objecttrees.html">Object Trees and Object Ownership</a>.)</td></tr>
<tr><td valign="top"><tt>QScriptEngine::ScriptOwnership</tt></td><td align="center" valign="top"><tt>1</tt></td><td valign="top">The value is owned by the script environment. The associated data will be deleted when appropriate (i.e&#x2e; after the garbage collector has discovered that there are no more live references to the value).</td></tr>
<tr><td valign="top"><tt>QScriptEngine::AutoOwnership</tt></td><td align="center" valign="top"><tt>2</tt></td><td valign="top">If the associated object has a parent, the Qt ownership rules apply (QtOwnership); otherwise, the object is owned by the script environment (ScriptOwnership).</td></tr>
</table></p>
<hr />
<h2>Member Function Documentation</h2>
<h3 class="fn"><a name="QScriptEngine"></a>QScriptEngine::QScriptEngine ()</h3>
<p>Constructs a <a href="qscriptengine.html">QScriptEngine</a> object.</p>
<p>The <a href="qscriptengine.html#globalObject">globalObject</a>() is initialized to have properties as described in <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</a>, Section 15.1&#x2e;</p>
<h3 class="fn"><a name="QScriptEngine-2"></a>QScriptEngine::QScriptEngine ( <a href="qobject.html">QObject</a> * <i>parent</i> )</h3>
<p>Constructs a <a href="qscriptengine.html">QScriptEngine</a> object with the given <i>parent</i>.</p>
<p>The <a href="qscriptengine.html#globalObject">globalObject</a>() is initialized to have properties as described in <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</a>, Section 15.1&#x2e;</p>
<h3 class="fn"><a name="dtor.QScriptEngine"></a>QScriptEngine::~QScriptEngine ()&nbsp;&nbsp;<tt> [virtual]</tt></h3>
<p>Destroys this <a href="qscriptengine.html">QScriptEngine</a>.</p>
<h3 class="fn"><a name="canEvaluate"></a>bool QScriptEngine::canEvaluate ( const <a href="qstring.html">QString</a> &amp; <i>program</i> ) const</h3>
<p>Returns true if <i>program</i> can be evaluated; i.e&#x2e; the code is sufficient to determine whether it appears to be a syntactically correct program, or contains a syntax error.</p>
<p>This function returns false if <i>program</i> is incomplete; i.e&#x2e; the input is syntactically correct up to the point where the input is terminated.</p>
<p>Note that this function only does a static check of <i>program</i>; e.g&#x2e; it does not check whether references to variables are valid, and so on.</p>
<p>A typical usage of canEvaluate() is to implement an interactive interpreter for <a href="qtscript.html">QtScript</a>. The user is repeatedly queried for individual lines of code; the lines are concatened internally, and only when canEvaluate() returns true for the resulting program is it passed to <a href="qscriptengine.html#evaluate">evaluate</a>().</p>
<p>The following are some examples to illustrate the behavior of canEvaluate(). (Note that all example inputs are assumed to have an explicit newline as their last character, since otherwise the <a href="qtscript.html">QtScript</a> parser would automatically insert a semi-colon character at the end of the input, and this could cause canEvaluate() to produce different results.)</p>
<p>Given the input</p>
<pre> if (hello &amp;&amp; world)
   print(&quot;hello world&quot;);</pre>
<p>canEvaluate() will return true, since the program appears to be complete.</p>
<p>Given the input</p>
<pre> if (hello &amp;&amp;</pre>
<p>canEvaluate() will return false, since the if-statement is not complete, but is syntactically correct so far.</p>
<p>Given the input</p>
<pre> 0 = 0</pre>
<p>canEvaluate() will return true, but <a href="qscriptengine.html#evaluate">evaluate</a>() will throw a SyntaxError given the same input.</p>
<p>Given the input</p>
<pre> ./test.js</pre>
<p>canEvaluate() will return true, even though the code is clearly not syntactically valid <a href="qtscript.html">QtScript</a> code. <a href="qscriptengine.html#evaluate">evaluate</a>() will throw a SyntaxError when this code is evaluated.</p>
<p>Given the input</p>
<pre> foo[&quot;bar&quot;]</pre>
<p>canEvaluate() will return true, but <a href="qscriptengine.html#evaluate">evaluate</a>() will throw a ReferenceError if <tt>foo</tt> is not defined in the script environment.</p>
<p>See also <a href="qscriptengine.html#evaluate">evaluate</a>().</p>
<h3 class="fn"><a name="collectGarbage"></a>void QScriptEngine::collectGarbage ()</h3>
<p>Runs the garbage collector.</p>
<p>The garbage collector will attempt to reclaim memory by locating and disposing of objects that are no longer reachable in the script environment.</p>
<p>Normally you don't need to call this function; the garbage collector will automatically be invoked when the <a href="qscriptengine.html">QScriptEngine</a> decides that it's wise to do so (i.e&#x2e; when a certain number of new objects have been created). However, you can call this function to explicitly request that garbage collection should be performed as soon as possible.</p>
<h3 class="fn"><a name="currentContext"></a><a href="qscriptcontext.html">QScriptContext</a> * QScriptEngine::currentContext () const</h3>
<p>Returns the current context.</p>
<p>The current context is typically accessed to retrieve the arguments and `this' object in native functions; for convenience, it is available as the first argument in <a href="qscriptengine.html#FunctionSignature-typedef">QScriptEngine::FunctionSignature</a>.</p>
<h3 class="fn"><a name="defaultPrototype"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::defaultPrototype ( int <i>metaTypeId</i> ) const</h3>
<p>Returns the default prototype associated with the given <i>metaTypeId</i>, or an invalid <a href="qscriptvalue.html">QScriptValue</a> if no default prototype has been set.</p>
<p>See also <a href="qscriptengine.html#setDefaultPrototype">setDefaultPrototype</a>().</p>
<h3 class="fn"><a name="evaluate"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::evaluate ( const <a href="qstring.html">QString</a> &amp; <i>program</i>, const <a href="qstring.html">QString</a> &amp; <i>fileName</i> = QString(), int <i>lineNumber</i> = 1 )</h3>
<p>Evaluates <i>program</i>, using <i>lineNumber</i> as the base line number, and returns the result of the evaluation.</p>
<p>The script code will be evaluated in the current context.</p>
<p>The evaluation of <i>program</i> can cause an exception in the engine; in this case the return value will be the exception that was thrown (typically an <tt>Error</tt> object). You can call <a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a>() to determine if an exception occurred in the last call to evaluate().</p>
<p><i>lineNumber</i> is used to specify a starting line number for <i>program</i>; line number information reported by the engine that pertain to this evaluation (e.g&#x2e; <a href="qscriptengine.html#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</a>()) will be based on this argument. For example, if <i>program</i> consists of two lines of code, and the statement on the second line causes a script exception, <a href="qscriptengine.html#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</a>() would return the given <i>lineNumber</i> plus one. When no starting line number is specified, line numbers will be 1-based.</p>
<p><i>fileName</i> is used for error reporting. For example in error objects the file name is accessible through the &quot;fileName&quot; property if it's provided with this function.</p>
<p>See also <a href="qscriptengine.html#canEvaluate">canEvaluate</a>() and <a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a>().</p>
<h3 class="fn"><a name="fromScriptValue"></a>T QScriptEngine::fromScriptValue ( const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>value</i> )</h3>
<p>Returns the given <i>value</i> converted to the template type <tt>T</tt>.</p>
<p>Note that <tt>T</tt> must be known to <a href="qmetatype.html">QMetaType</a>.</p>
<p>See <a href="qtscript.html#conversion-between-qtscript-and-c-types">Conversion Between QtScript and C++ Types</a> for a description of the built-in type conversion provided by <a href="qtscript.html">QtScript</a>.</p>
<p><b>Warning:</b> This function is not available with MSVC 6. Use <a href="qscriptengine.html#qScriptValueToValue">qScriptValueToValue</a>() or <a href="qscriptvalue.html#qscriptvalue_cast">qscriptvalue_cast</a>() instead if you need to support that version of the compiler.</p>
<p>See also <a href="qscriptengine.html#toScriptValue">toScriptValue</a>() and <a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a>().</p>
<h3 class="fn"><a name="globalObject"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::globalObject () const</h3>
<p>Returns this engine's Global Object.</p>
<p>The Global Object contains the built-in objects that are part of <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</a>, such as Math, Date and String. Additionally, you can set properties of the Global Object to make your own extensions available to all script code. Non-local variables in script code will be created as properties of the Global Object, as well as local variables in global code.</p>
<h3 class="fn"><a name="hasUncaughtException"></a>bool QScriptEngine::hasUncaughtException () const</h3>
<p>Returns true if the last script evaluation (whether direct or indirect) resulted in an uncaught exception; otherwise returns false.</p>
<p>The exception state is cleared every time a script function call is done in the engine, or when <a href="qscriptengine.html#evaluate">evaluate</a>() is called.</p>
<p>See also <a href="qscriptengine.html#uncaughtException">uncaughtException</a>(), <a href="qscriptengine.html#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</a>(), and <a href="qscriptengine.html#uncaughtExceptionBacktrace">uncaughtExceptionBacktrace</a>().</p>
<h3 class="fn"><a name="importExtension"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::importExtension ( const <a href="qstring.html">QString</a> &amp; <i>extension</i> )</h3>
<p>Imports the given <i>extension</i> into this <a href="qscriptengine.html">QScriptEngine</a>. Returns <a href="qscriptengine.html#undefinedValue">undefinedValue</a>() if the extension was successfully imported. You can call <a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a>() to check if an error occurred; in that case, the return value is the value that was thrown by the exception (usually an <tt>Error</tt> object).</p>
<p><a href="qscriptengine.html">QScriptEngine</a> ensures that a particular extension is only imported once; subsequent calls to importExtension() with the same extension name will do nothing and return <a href="qscriptengine.html#undefinedValue">undefinedValue</a>().</p>
<p>See also <a href="qscriptextensionplugin.html">QScriptExtensionPlugin</a> and <a href="qtscriptextensions.html">Creating QtScript Extensions</a>.</p>
<h3 class="fn"><a name="newArray"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newArray ( <a href="qtglobal.html#uint-typedef">uint</a> <i>length</i> = 0 )</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object of class Array with the given <i>length</i>.</p>
<p>See also <a href="qscriptengine.html#newObject">newObject</a>().</p>
<h3 class="fn"><a name="newDate"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newDate ( qsreal <i>value</i> )</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object of class Date with the given <i>value</i> (the number of milliseconds since 01 January 1970, UTC).</p>
<h3 class="fn"><a name="newDate-2"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newDate ( const <a href="qdatetime.html">QDateTime</a> &amp; <i>value</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Creates a <a href="qtscript.html">QtScript</a> object of class Date from the given <i>value</i>.</p>
<p>See also <a href="qscriptvalue.html#toDateTime">QScriptValue::toDateTime</a>().</p>
<h3 class="fn"><a name="newFunction"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newFunction ( <a href="qscriptengine.html#FunctionSignature-typedef">FunctionSignature</a> <i>fun</i>, int <i>length</i> = 0 )</h3>
<p>Creates a <a href="qscriptvalue.html">QScriptValue</a> that wraps a native (C++) function. <i>fun</i> must be a C++ function with signature <a href="qscriptengine.html#FunctionSignature-typedef">QScriptEngine::FunctionSignature</a>. <i>length</i> is the number of arguments that <i>fun</i> expects; this becomes the <tt>length</tt> property of the created <a href="qscriptvalue.html">QScriptValue</a>.</p>
<p>Note that <i>length</i> only gives an indication of the number of arguments that the function expects; an actual invocation of a function can include any number of arguments. You can check the <a href="qscriptcontext.html#argumentCount">argumentCount()</a> of the <a href="qscriptcontext.html">QScriptContext</a> associated with the invocation to determine the actual number of arguments passed.</p>
<p>By combining newFunction() and the property flags <a href="qscriptvalue.html#PropertyFlag-enum">QScriptValue::PropertyGetter</a> and <a href="qscriptvalue.html#PropertyFlag-enum">QScriptValue::PropertySetter</a>, you can create script object properties that behave like normal properties in script code, but are in fact accessed through functions (analogous to how properties work in <a href="properties.html">Qt's Property System</a>). Example:</p>
<pre> static QScriptValue getSetFoo(QScriptContext *context, QScriptEngine *engine)
 {
     QScriptValue callee = context-&gt;callee();
     if (context-&gt;argumentCount() == 1) <span class="comment">//</span> writing?
         callee.setProperty(&quot;value&quot;, context-&gt;argument(0));
     return callee.property(&quot;value&quot;);
 }

 ....

 QScriptValue object = engine.newObject();
 object.setProperty(&quot;foo&quot;, engine.newFunction(getSetFoo),
     QScriptValue::PropertyGetter | QScriptValue::PropertySetter);</pre>
<p>When the property <tt>foo</tt> of the script object is subsequently accessed in script code, <tt>getSetFoo()</tt> will be invoked to handle the access. In this particular case, we chose to store the &quot;real&quot; value of <tt>foo</tt> as a property of the accessor function itself; you are of course free to do whatever you like in this function.</p>
<p>In the above example, a single native function was used to handle both reads and writes to the property; the argument count is used to determine if we are handling a read or write. You can also use two separate functions; just specify the relevant flag (<a href="qscriptvalue.html#PropertyFlag-enum">QScriptValue::PropertyGetter</a> or <a href="qscriptvalue.html#PropertyFlag-enum">QScriptValue::PropertySetter</a>) when setting the property, e.g&#x2e;:</p>
<pre> QScriptValue object = engine.newObject();
 object.setProperty(&quot;foo&quot;, engine.newFunction(getFoo), QScriptValue::PropertyGetter);
 object.setProperty(&quot;foo&quot;, engine.newFunction(setFoo), QScriptValue::PropertySetter);</pre>
<p>See also <a href="qscriptvalue.html#call">QScriptValue::call</a>().</p>
<h3 class="fn"><a name="newFunction-2"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newFunction ( <a href="qscriptengine.html#FunctionSignature-typedef">FunctionSignature</a> <i>fun</i>, const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>prototype</i>, int <i>length</i> = 0 )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Creates a constructor function from <i>fun</i>, with the given <i>length</i>. The <tt>prototype</tt> property of the resulting function is set to be the given <i>prototype</i>. The <tt>constructor</tt> property of <i>prototype</i> is set to be the resulting function.</p>
<p>When a function is called as a constructor (e.g&#x2e; <tt>new Foo()</tt>), the `this' object associated with the function call is the new object that the function is expected to initialize; the prototype of this default constructed object will be the function's public <tt>prototype</tt> property. If you always want the function to behave as a constructor (e.g&#x2e; <tt>Foo()</tt> should also create a new object), or if you need to create your own object rather than using the default `this' object, you should make sure that the prototype of your object is set correctly; either by setting it manually, or, when wrapping a custom type, by having registered the <a href="qscriptengine.html#defaultPrototype">defaultPrototype</a>() of that type. Example:</p>
<pre> QScriptValue Foo(QScriptContext *context, QScriptEngine *engine)
 {
     if (context-&gt;calledAsConstructor()) {
         <span class="comment">//</span> initialize the new object
         context-&gt;thisObject().setProperty(&quot;bar&quot;, ...);
         <span class="comment">//</span> ...
         <span class="comment">//</span> return a non-object value to indicate that the
         <span class="comment">//</span> thisObject() should be the result of the &quot;new Foo()&quot; expression
         return engine-&gt;undefinedValue();
     } else {
         <span class="comment">//</span> not called as &quot;new Foo()&quot;, just &quot;Foo()&quot;
         <span class="comment">//</span> create our own object and return that one
         QScriptValue object = engine-&gt;newObject();
         object.setPrototype(context-&gt;callee().property(&quot;prototype&quot;));
         object.setProperty(&quot;baz&quot;, ...);
         return object;
     }
 }

 ...

 QScriptValue fooProto = engine-&gt;newObject();
 fooProto.setProperty(&quot;whatever&quot;, ...);
 engine-&gt;globalObject().setProperty(&quot;Foo&quot;, engine-&gt;newFunction(Foo, fooProto));</pre>
<p>To wrap a custom type and provide a constructor for it, you'd typically do something like this:</p>
<pre> class Bar { ... };

 Q_DECLARE_METATYPE(Bar)

 QScriptValue constructBar(QScriptContext *context, QScriptEngine *engine)
 {
     Bar bar;
     <span class="comment">//</span> initialize from arguments in context, if desired
     ...
     return engine-&gt;toScriptValue(bar);
 }

 class BarPrototype : public QObject, public QScriptable
 {
<span class="comment"> //</span> provide the scriptable interface of this type using slots and properties
 ...
 };

 ...

<span class="comment"> //</span> create and register the Bar prototype and constructor in the engine
 BarPrototype *barPrototypeObject = new BarPrototype(...);
 QScriptValue barProto = engine-&gt;newQObject(barPrototypeObject);
 engine-&gt;setDefaultPrototype(qMetaTypeId&lt;Bar&gt;, barProto);
 QScriptValue barCtor = engine-&gt;newFunction(constructBar, barProto);
 engine-&gt;globalObject().setProperty(&quot;Bar&quot;, barCtor);</pre>
<h3 class="fn"><a name="newObject"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newObject ()</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object of class Object.</p>
<p>The prototype of the created object will be the Object prototype object.</p>
<p>See also <a href="qscriptengine.html#newArray">newArray</a>() and <a href="qscriptvalue.html#setProperty">QScriptValue::setProperty</a>().</p>
<h3 class="fn"><a name="newQMetaObject"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newQMetaObject ( const <a href="qmetaobject.html">QMetaObject</a> * <i>metaObject</i>, const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>ctor</i> = QScriptValue() )</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object that represents a <a href="qobject.html">QObject</a> class, using the the given <i>metaObject</i> and constructor <i>ctor</i>.</p>
<p>Enums of <i>metaObject</i> are available as properties of the created <a href="qscriptvalue.html">QScriptValue</a>. When the class is called as a function, <i>ctor</i> will be called to create a new instance of the class.</p>
<p>See also <a href="qscriptengine.html#newQObject">newQObject</a>().</p>
<h3 class="fn"><a name="newQObject"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newQObject ( <a href="qobject.html">QObject</a> * <i>object</i>, <a href="qscriptengine.html#ValueOwnership-enum">ValueOwnership</a> <i>ownership</i> = QtOwnership, const <a href="qscriptengine.html#QObjectWrapOption-enum">QObjectWrapOptions</a> &amp; <i>options</i> = 0 )</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object that wraps the given <a href="qobject.html">QObject</a> <i>object</i>, using the given <i>ownership</i>. The given <i>options</i> control various aspects of the interaction with the resulting script object.</p>
<p>Signals and slots, properties and children of <i>object</i> are available as properties of the created <a href="qscriptvalue.html">QScriptValue</a>. For more information, see the <a href="qtscript.html">QtScript</a> documentation.</p>
<p>If <i>object</i> is a null pointer, this function returns <a href="qscriptengine.html#nullValue">nullValue</a>().</p>
<p>If the given <i>object</i> is deleted outside of <a href="qtscript.html">QtScript</a>'s control, any attempt to access the deleted <a href="qobject.html">QObject</a>'s members through the <a href="qtscript.html">QtScript</a> wrapper object (either by script code or C++) will result in a script exception.</p>
<p>See also <a href="qscriptvalue.html#toQObject">QScriptValue::toQObject</a>().</p>
<h3 class="fn"><a name="newRegExp"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newRegExp ( const <a href="qregexp.html">QRegExp</a> &amp; <i>regexp</i> )</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object of class RegExp with the given <i>regexp</i>.</p>
<p>See also <a href="qscriptvalue.html#toRegExp">QScriptValue::toRegExp</a>().</p>
<h3 class="fn"><a name="newRegExp-2"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newRegExp ( const <a href="qstring.html">QString</a> &amp; <i>pattern</i>, const <a href="qstring.html">QString</a> &amp; <i>flags</i> )</h3>
<p>This is an overloaded member function, provided for convenience.</p>
<p>Creates a <a href="qtscript.html">QtScript</a> object of class RegExp with the given <i>pattern</i> and <i>flags</i>.</p>
<h3 class="fn"><a name="newVariant"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::newVariant ( const <a href="qvariant.html">QVariant</a> &amp; <i>value</i> )</h3>
<p>Creates a <a href="qtscript.html">QtScript</a> object holding the given variant <i>value</i>.</p>
<p>If a default prototype has been registered with the meta type id of <i>value</i>, then the prototype of the created object will be that prototype; otherwise, the prototype will be the Object prototype object.</p>
<p>See also <a href="qscriptengine.html#setDefaultPrototype">setDefaultPrototype</a>() and <a href="qscriptvalue.html#toVariant">QScriptValue::toVariant</a>().</p>
<h3 class="fn"><a name="nullValue"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::nullValue ()</h3>
<p>Returns a <a href="qscriptvalue.html">QScriptValue</a> of the primitive type Null.</p>
<p>See also <a href="qscriptengine.html#undefinedValue">undefinedValue</a>().</p>
<h3 class="fn"><a name="popContext"></a>void QScriptEngine::popContext ()</h3>
<p>Pops the current execution context and restores the previous one. This function must be used in conjunction with <a href="qscriptengine.html#pushContext">pushContext</a>().</p>
<p>See also <a href="qscriptengine.html#pushContext">pushContext</a>().</p>
<h3 class="fn"><a name="processEventsInterval"></a>int QScriptEngine::processEventsInterval () const</h3>
<p>Returns the interval in milliseconds between calls to <a href="qcoreapplication.html#processEvents">QCoreApplication::processEvents</a>() while the interpreter is running.</p>
<p>See also <a href="qscriptengine.html#setProcessEventsInterval">setProcessEventsInterval</a>().</p>
<h3 class="fn"><a name="pushContext"></a><a href="qscriptcontext.html">QScriptContext</a> * QScriptEngine::pushContext ()</h3>
<p>Enters a new execution context and returns the associated <a href="qscriptcontext.html">QScriptContext</a> object.</p>
<p>Once you are done with the context, you should call <a href="qscriptengine.html#popContext">popContext</a>() to restore the old context.</p>
<p>By default, the `this' object of the new context is the Global Object. The context's <a href="qscriptcontext.html#callee">callee</a>() will be invalid.</p>
<p>This function is useful when you want to evaluate script code as if it were the body of a function. You can use the context's <a href="qscriptcontext.html#activationObject">activationObject</a>() to initialize local variables that will be available to scripts. Example:</p>
<pre> QScriptEngine engine;
 QScriptContext *context = engine.pushContext();
 context-&gt;activationObject().setProperty(&quot;myArg&quot;, QScriptValue(&amp;engine, 123));
 engine.evaluate(&quot;var tmp = myArg + 42&quot;);
 ...
 engine.popContext();</pre>
<p>In the above example, the new variable &quot;tmp&quot; defined in the script will be local to the context; in other words, the script doesn't have any effect on the global environment.</p>
<p>See also <a href="qscriptengine.html#popContext">popContext</a>().</p>
<h3 class="fn"><a name="scriptValueFromQMetaObject"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::scriptValueFromQMetaObject ()</h3>
<p>Creates a <a href="qscriptvalue.html">QScriptValue</a> that represents the Qt class <tt>T</tt>.</p>
<p>This function is used in combination with one of the <a href="qscriptengine.html#Q_SCRIPT_DECLARE_QMETAOBJECT">Q_SCRIPT_DECLARE_QMETAOBJECT</a>() macro. Example:</p>
<pre> Q_SCRIPT_DECLARE_QMETAOBJECT(QLineEdit, QWidget*)

 ...

 QScriptValue lineEditClass = engine.scriptValueFromQMetaObject&lt;QLineEdit&gt;();
 engine.globalObject().setProperty(&quot;QLineEdit&quot;, lineEditClass);</pre>
<p><b>Warning:</b> This function is not available with MSVC 6. Use <a href="qscriptengine.html#qScriptValueFromQMetaObject">qScriptValueFromQMetaObject</a>() instead if you need to support that version of the compiler.</p>
<h3 class="fn"><a name="setDefaultPrototype"></a>void QScriptEngine::setDefaultPrototype ( int <i>metaTypeId</i>, const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>prototype</i> )</h3>
<p>Sets the default prototype of the given <i>metaTypeId</i> to <i>prototype</i>.</p>
<p>The default prototype provides a script interface for values of type <i>metaTypeId</i> when a value of that type is accessed from script code. Whenever the script engine (implicitly or explicitly) creates a <a href="qscriptvalue.html">QScriptValue</a> from a value of type <i>metaTypeId</i>, the default prototype will be set as the <a href="qscriptvalue.html">QScriptValue</a>'s prototype.</p>
<p>See also <a href="qscriptengine.html#defaultPrototype">defaultPrototype</a>(), <a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a>(), <a href="qscriptable.html">QScriptable</a>, and <a href="script-defaultprototypes.html">Default Prototypes Example</a>.</p>
<h3 class="fn"><a name="setProcessEventsInterval"></a>void QScriptEngine::setProcessEventsInterval ( int <i>interval</i> )</h3>
<p>Sets the interval between calls to QCoreApplication::processEvents to <i>interval</i> milliseconds.</p>
<p>While the interpreter is running, all event processing is by default blocked. This means for instance that the gui will not be updated and timers will not be fired. To allow event processing during interpreter execution one can specify the processing interval to be a positive value, indicating the number of milliseconds between each time <a href="qcoreapplication.html#processEvents">QCoreApplication::processEvents</a>() is called.</p>
<p>The default value is -1, which disables event processing during interpreter execution.</p>
<p>See also <a href="qscriptengine.html#processEventsInterval">processEventsInterval</a>().</p>
<h3 class="fn"><a name="toScriptValue"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::toScriptValue ( const T &amp; <i>value</i> )</h3>
<p>Creates a <a href="qscriptvalue.html">QScriptValue</a> with the given <i>value</i>.</p>
<p>Note that the template type <tt>T</tt> must be known to <a href="qmetatype.html">QMetaType</a>.</p>
<p>See <a href="qtscript.html#conversion-between-qtscript-and-c-types">Conversion Between QtScript and C++ Types</a> for a description of the built-in type conversion provided by <a href="qtscript.html">QtScript</a>. By default, the types that are not specially handled by <a href="qtscript.html">QtScript</a> are represented as QVariants (e.g&#x2e; the <i>value</i> is passed to <a href="qscriptengine.html#newVariant">newVariant</a>()); you can change this behavior by installing your own type conversion functions with <a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a>().</p>
<p><b>Warning:</b> This function is not available with MSVC 6. Use <a href="qscriptengine.html#qScriptValueFromValue">qScriptValueFromValue</a>() instead if you need to support that version of the compiler.</p>
<p>See also <a href="qscriptengine.html#fromScriptValue">fromScriptValue</a>() and <a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a>().</p>
<h3 class="fn"><a name="uncaughtException"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::uncaughtException () const</h3>
<p>Returns the current uncaught exception, or an invalid <a href="qscriptvalue.html">QScriptValue</a> if there is no uncaught exception.</p>
<p>The exception value is typically an <tt>Error</tt> object; in that case, you can call toString() on the return value to obtain an error message.</p>
<p>See also <a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a>(), <a href="qscriptengine.html#uncaughtExceptionLineNumber">uncaughtExceptionLineNumber</a>(), and <a href="qscriptengine.html#uncaughtExceptionBacktrace">uncaughtExceptionBacktrace</a>().</p>
<h3 class="fn"><a name="uncaughtExceptionBacktrace"></a><a href="qstringlist.html">QStringList</a> QScriptEngine::uncaughtExceptionBacktrace () const</h3>
<p>Returns a human-readable backtrace of the last uncaught exception.</p>
<p>Each line is of the form <tt>&lt;function-name&gt;(&lt;arguments&gt;)@&lt;file-name&gt;:&lt;line-number&gt;</tt>.</p>
<p>See also <a href="qscriptengine.html#uncaughtException">uncaughtException</a>().</p>
<h3 class="fn"><a name="uncaughtExceptionLineNumber"></a>int QScriptEngine::uncaughtExceptionLineNumber () const</h3>
<p>Returns the line number where the last uncaught exception occurred.</p>
<p>Line numbers are 1-based, unless a different base was specified as the second argument to <a href="qscriptengine.html#evaluate">evaluate</a>().</p>
<p>See also <a href="qscriptengine.html#hasUncaughtException">hasUncaughtException</a>() and <a href="qscriptengine.html#uncaughtExceptionBacktrace">uncaughtExceptionBacktrace</a>().</p>
<h3 class="fn"><a name="undefinedValue"></a><a href="qscriptvalue.html">QScriptValue</a> QScriptEngine::undefinedValue ()</h3>
<p>Returns a <a href="qscriptvalue.html">QScriptValue</a> of the primitive type Undefined.</p>
<p>See also <a href="qscriptengine.html#nullValue">nullValue</a>().</p>
<hr />
<h2>Related Non-Members</h2>
<h3 class="fn"><a name="FunctionSignature-typedef"></a>typedef QScriptEngine::FunctionSignature</h3>
<p>The function signature <tt>QScriptValue f(QScriptContext *, QScriptEngine *)</tt>.</p>
<p>A function with such a signature can be passed to <a href="qscriptengine.html#newFunction">QScriptEngine::newFunction</a>() to wrap the function.</p>
<h3 class="fn"><a name="qScriptRegisterMetaType"></a>int qScriptRegisterMetaType ( QScriptEngine * <i>engine</i>, <a href="qscriptvalue.html">QScriptValue</a>(* ) ( QScriptEngine *, const T &amp; t ) <i>toScriptValue</i>, void(* ) ( const <a href="qscriptvalue.html">QScriptValue</a> &amp;, T &amp; t ) <i>fromScriptValue</i>, const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>prototype</i> = QScriptValue() )</h3>
<p>Registers the type <tt>T</tt> in the given <i>engine</i>. <i>toScriptValue</i> must be a function that will convert from a value of type <tt>T</tt> to a <a href="qscriptvalue.html">QScriptValue</a>, and <i>fromScriptValue</i> a function that does the opposite. <i>prototype</i>, if valid, is the prototype that's set on QScriptValues returned by <i>toScriptValue</i>.</p>
<p>Returns the internal ID used by <a href="qmetatype.html">QMetaType</a>.</p>
<p>You only need to call this function if you want to provide custom conversion of values of type <tt>T</tt>, i.e&#x2e; if the default <a href="qvariant.html">QVariant</a>-based representation and conversion is not appropriate. If you only want to define a common script interface for values of type <tt>T</tt>, and don't care how those values are represented, use <a href="qscriptengine.html#setDefaultPrototype">setDefaultPrototype</a>() instead.</p>
<p>You need to declare the custom type first with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>().</p>
<p>After a type has been registered, you can convert from a <a href="qscriptvalue.html">QScriptValue</a> to that type using <a href="qscriptengine.html#fromScriptValue">fromScriptValue</a>(), and create a <a href="qscriptvalue.html">QScriptValue</a> from a value of that type using <a href="qscriptengine.html#toScriptValue">toScriptValue</a>(). The engine will take care of calling the proper conversion function when calling C++ slots, and when getting or setting a C++ property; i.e&#x2e; the custom type may be used seamlessly on both the C++ side and the script side.</p>
<p>The following is an example of how to use this function. We will specify custom conversion of our type <tt>MyStruct</tt>. Here's the C++ type:</p>
<pre> struct MyStruct {
   int x;
   int y;
 };</pre>
<p>We must declare it so that the type will be known to <a href="qmetatype.html">QMetaType</a>:</p>
<pre> Q_DECLARE_METATYPE(MyStruct)</pre>
<p>Next, the <tt>MyStruct</tt> conversion functions. We represent the <tt>MyStruct</tt> value as a script object and just copy the properties:</p>
<pre> QScriptValue toScriptValue(QScriptEngine *engine, const MyStruct &amp;s)
 {
   QScriptValue obj = engine-&gt;newObject();
   obj.setProperty(&quot;x&quot;, QScriptValue(engine, s.x));
   obj.setProperty(&quot;y&quot;, QScriptValue(engine, s.y));
   return obj;
 }

 void fromScriptValue(const QScriptValue &amp;obj, MyStruct &amp;s)
 {
   s.x = obj.property(&quot;x&quot;).toInt32();
   s.y = obj.property(&quot;y&quot;).toInt32();
 }</pre>
<p>Now we can register <tt>MyStruct</tt> with the engine:</p>
<pre> qScriptRegisterMetaType(engine, toScriptValue, fromScriptValue);</pre>
<p>Working with <tt>MyStruct</tt> values is now easy:</p>
<pre> MyStruct s = qscriptvalue_cast&lt;MyStruct&gt;(context-&gt;argument(0));
 ...
 MyStruct s2;
 s2.x = s.x + 10;
 s2.y = s.y + 20;
 QScriptValue v = engine-&gt;toScriptValue(s2);</pre>
<p>If you want to be able to construct values of your custom type from script code, you have to register a constructor function for the type. For example:</p>
<pre> QScriptValue createMyStruct(QScriptContext *, QScriptEngine *engine)
 {
     MyStruct s;
     s.x = 123;
     s.y = 456;
     return engine-&gt;toScriptValue(s);
 }
 ...
 QScriptValue ctor = engine.newFunction(createMyStruct);
 engine.globalObject().setProperty(&quot;MyStruct&quot;, ctor);</pre>
<p>See also <a href="qscriptengine.html#qScriptRegisterSequenceMetaType">qScriptRegisterSequenceMetaType</a>() and <a href="qmetatype.html#qRegisterMetaType">qRegisterMetaType</a>().</p>
<h3 class="fn"><a name="qScriptRegisterSequenceMetaType"></a>int qScriptRegisterSequenceMetaType ( QScriptEngine * <i>engine</i>, const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>prototype</i> = QScriptValue() )</h3>
<p>Registers the sequence type <tt>T</tt> in the given <i>engine</i>. This function provides conversion functions that convert between <tt>T</tt> and Qt Script <tt>Array</tt> objects. <tt>T</tt> must provide a const_iterator class and begin(), end() and push_back() functions. If <i>prototype</i> is valid, it will be set as the prototype of <tt>Array</tt> objects due to conversion from <tt>T</tt>; otherwise, the standard <tt>Array</tt> prototype will be used.</p>
<p>Returns the internal ID used by <a href="qmetatype.html">QMetaType</a>.</p>
<p>You need to declare the container type first with <a href="qmetatype.html#Q_DECLARE_METATYPE">Q_DECLARE_METATYPE</a>(). Example:</p>
<pre> Q_DECLARE_METATYPE(QVector&lt;int&gt;)

 ...

 qScriptRegisterSequenceMetaType&lt;QVector&lt;int&gt; &gt;(engine);
 ...
 QVector&lt;int&gt; v = qscriptvalue_cast&lt;QVector&lt;int&gt; &gt;(engine-&gt;evaluate(&quot;[5, 1, 3, 2]&quot;));
 qSort(v.begin(), v.end());
 QScriptValue a = engine-&gt;toScriptValue(v);
 qDebug() &lt;&lt; a.toString(); <span class="comment">//</span> outputs &quot;[1, 2, 3, 5]&quot;</pre>
<p>See also <a href="qscriptengine.html#qScriptRegisterMetaType">qScriptRegisterMetaType</a>().</p>
<h3 class="fn"><a name="qScriptValueFromQMetaObject"></a><a href="qscriptvalue.html">QScriptValue</a> qScriptValueFromQMetaObject ( QScriptEngine * <i>engine</i> )</h3>
<p>Uses <i>engine</i> to create a <a href="qscriptvalue.html">QScriptValue</a> that represents the Qt class <tt>T</tt>.</p>
<p>This function is equivalent to <a href="qscriptengine.html#scriptValueFromQMetaObject">QScriptEngine::scriptValueFromQMetaObject</a>(). It is provided as a work-around for MSVC 6, which doesn't support member template functions.</p>
<p>This function was introduced in Qt 4.3.</p>
<h3 class="fn"><a name="qScriptValueFromSequence"></a><a href="qscriptvalue.html">QScriptValue</a> qScriptValueFromSequence ( QScriptEngine * <i>engine</i>, const Container &amp; <i>container</i> )</h3>
<p>Creates an array in the form of a <a href="qscriptvalue.html">QScriptValue</a> using the given <i>engine</i> with the given <i>container</i> of template type <tt>Container</tt>.</p>
<p>The <tt>Container</tt> type must provide a <tt>const_iterator</tt> class to enable the contents of the container to be copied into the array.</p>
<p>Additionally, the type of each element in the sequence should be suitable for conversion to a <a href="qscriptvalue.html">QScriptValue</a>. See <a href="qtscript.html#conversion-between-qtscript-and-c-types">Conversion Between QtScript and C++ Types</a> for more information about the restrictions on types that can be used with <a href="qscriptvalue.html">QScriptValue</a>.</p>
<p>This function was introduced in Qt 4.3.</p>
<p>See also <a href="qscriptengine.html#qScriptValueFromValue">qScriptValueFromValue</a>().</p>
<h3 class="fn"><a name="qScriptValueFromValue"></a><a href="qscriptvalue.html">QScriptValue</a> qScriptValueFromValue ( QScriptEngine * <i>engine</i>, const T &amp; <i>value</i> )</h3>
<p>Creates a <a href="qscriptvalue.html">QScriptValue</a> using the given <i>engine</i> with the given <i>value</i> of template type <tt>T</tt>.</p>
<p>This function is equivalent to <a href="qscriptengine.html#toScriptValue">QScriptEngine::toScriptValue</a>(). It is provided as a work-around for MSVC 6, which doesn't support member template functions.</p>
<p>This function was introduced in Qt 4.3.</p>
<p>See also <a href="qscriptengine.html#qScriptValueToValue">qScriptValueToValue</a>().</p>
<h3 class="fn"><a name="qScriptValueToSequence"></a>void qScriptValueToSequence ( const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>value</i>, Container &amp; <i>container</i> )</h3>
<p>Copies the elements in the sequence specified by <i>value</i> to the given <i>container</i> of template type <tt>Container</tt>.</p>
<p>The <i>value</i> used is typically an array, but any container can be copied as long as it provides a <tt>length</tt> property describing how many elements it contains.</p>
<p>Additionally, the type of each element in the sequence must be suitable for conversion to a C++ type from a <a href="qscriptvalue.html">QScriptValue</a>. See <a href="qtscript.html#conversion-between-qtscript-and-c-types">Conversion Between QtScript and C++ Types</a> for more information about the restrictions on types that can be used with <a href="qscriptvalue.html">QScriptValue</a>.</p>
<p>This function was introduced in Qt 4.3.</p>
<p>See also <a href="qscriptvalue.html#qscriptvalue_cast">qscriptvalue_cast</a>().</p>
<h3 class="fn"><a name="qScriptValueToValue"></a>T qScriptValueToValue ( const <a href="qscriptvalue.html">QScriptValue</a> &amp; <i>value</i> )</h3>
<p>Returns the given <i>value</i> converted to the template type <tt>T</tt>.</p>
<p>This function is equivalent to <a href="qscriptengine.html#fromScriptValue">QScriptEngine::fromScriptValue</a>(). It is provided as a work-around for MSVC 6, which doesn't support member template functions.</p>
<p>This function was introduced in Qt 4.3.</p>
<p>See also <a href="qscriptengine.html#qScriptValueFromValue">qScriptValueFromValue</a>().</p>
<hr />
<h2>Macro Documentation</h2>
<h3 class="fn"><a name="Q_SCRIPT_DECLARE_QMETAOBJECT"></a>Q_SCRIPT_DECLARE_QMETAOBJECT (  <i>QMetaObject</i>,  <i>ArgType</i> )</h3>
<p>Declares the given <i>QMetaObject</i>. Used in combination with <a href="qscriptengine.html#scriptValueFromQMetaObject">QScriptEngine::scriptValueFromQMetaObject</a>() to make enums and instantiation of <i>QMetaObject</i> available to script code. The constructor generated by this macro takes a single argument of type <i>ArgType</i>; typically the argument is the parent type of the new instance, in which case <i>ArgType</i> is <tt>QWidget*</tt> or <tt>QObject*</tt>. Objects created by the constructor will have <a href="qscriptengine.html#ValueOwnership-enum">QScriptEngine::AutoOwnership</a> ownership.</p>
<p>This function was introduced in Qt 4.3.</p>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008 <a href="trolltech.html">Trolltech</a></td>
<td width="40%" align="center"><a href="trademarks.html">Trademarks</a></td>
<td width="30%" align="right"><div align="right">Qt 4.3.5</div></td>
</tr></table></div></address></body>
</html>
