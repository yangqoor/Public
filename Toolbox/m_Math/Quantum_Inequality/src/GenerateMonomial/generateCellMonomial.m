% The function: generateCellMonomial(upper, list, varType)% Parameters:%	+ upper: integer%	+ varType: 0 if variables are projectors; or 1 if variables are observables.%	+ list: a cell of size 1 x n where K is the number of partitions. %		- If varType = 0, each element in the cell 'list' is also a cell. Its elements are arrays representing input groups. Each input group %         contains integers representing variables.%		- If varType = 1, each element in the cell 'list' is an array which represents a partition. Each array contains integers which %		  represents variables.%	Remark:%		- If x and y are different projectors that belong to the same "input groups", x * y = 0%		- The sum of all projectors within the same "input group" is I (identity)% 	+ hashGenMonoInfo: a hash table that contains how a list of monomials of certain order should be constructed.%		- The key of hashGenMonoInfo is the order of a monomial.%		- The associated data of each key is a cell E where:%			* E{1}: an integer indicating the number of partition that should be present in a monomial (i.e. a monomial generated should contain%						at least E{1} instances of variables from E{1} different partitions)%					E{1} = 0 means there is no restriction on monomials in terms of the number of partitions present.%			* E{2}: a string. There are only 2 cases:%					+ E{2} = 'full' means we take all monomials that satisfy E{1}. If E{2} = 'full', there is no need to input E{3} and E{4}%					+ E{2} = 'random' means we choose randomly some elements from the list of all monomials that satisfy E{1}%			* E{3}: a number.%			* E{4}: a string. There are only 2 cases:%					+ E{4} = 'absolute' means E{3} is an integer indicating the number of monomials we choose randomly.%					+ E{4} = 'ratio' means E{3} is a real number indicating the percentage over the total number of satisfying monomials that%							we choose randomly.%% Assumption: length(list) = K >= 1% The function returns a cell of monomials of non-negative degree less than or equal to the parameter 'upper' whose variables of type 'varType' and % satisfied the conditions specified in the array 'list'.%%function cellMonomial = generateCellMonomial(upperLim, list, varType, hashGenMonoInfo)	K = length(list);		% arrMonomial definitely contains the identity of order 0.	cellMonomial = cell(1, 0);		for order = 0 : upperLim		if ~hashGenMonoInfo.isKey(order)			% Use default mode: generate full list of monomials of order 'order' and choose all of them!			% The last argument of generatecellMonomialOrder is numPartitionPresent. numPartitionPresent = 0 means			%		there is no constraint on the monomials generated!			newCellMonomial = generateCellMonomialOrder(order, list, varType, 0);		else			criteria = hashGenMonoInfo(order);			newCellMonomial = generateCellMonomialOrder(order, list, varType, criteria{1});			if strcmpi(criteria{2}, 'random')				numMonomial = length(newCellMonomial);				if strcmpi(criteria{4}, 'absolute')					numChooseRandom = min(criteria{3}, numMonomial);				else					% The case 'ratio'					numChooseRandom = min(criteria{3} * numMonomial, numMonomial);				end								newCellMonomial = chooseRandom(newCellMonomial, numChooseRandom);			end		end		% Concatenate the new cell into the existing cell		cellMonomial = [cellMonomial, newCellMonomial];	endend