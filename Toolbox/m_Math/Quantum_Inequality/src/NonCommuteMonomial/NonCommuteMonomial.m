% Constructor: Creates a structure object of monomials in non-commutative variables.% Note that we do not reduce the monomial in the constructor.function obj = NonCommuteMonomial(varargin)	if nargin == 0		% Use default constructor: Create a zero monomial		obj.m_varOrdering = {};		obj.m_coeff = 0;		obj.m_degree = -2147483648;		% intmin('int32')		return;	end				if isstruct(varargin{1})		% Use copy constructor		if isfield(varargin{1}, 'm_varOrdering') && isfield(varargin{1}, 'm_degree') && isfield(varargin{1}, 'm_coeff')			obj = varargin{1};			return;		else			error('Type does not match');		end	end				% Use the full constructor	% varargin MUST have 2 elements	% varargin{1}: a cell array of size 1 x L. L is the number of partition. Each cell contains an array of integers	% 			   which indicates the ordering of variables of each partition in the monomial. An ordering of a partition	%			   may be empty; however, it must be present in varargin{1}.	%			   Note that variables are numbered from 1 to N (N is the total number of variables)	% varargin{2}: coefficient of the monomial.	% The program will not check L and N because it is the job of the class that uses NonCommuteMonomial.	% Note that only the zero monomial can have varargin{1} as an empty cell.				% Assign value	varOrdering = varargin{1};	coeff = varargin{2};			    % Calculate degree	% Zero monomials	THRESHOLD = 0.000000000001;	if (coeff < THRESHOLD && coeff > -THRESHOLD) || isempty(varOrdering)		% A zero monomial should have m_varOrdering as an empty cell		obj.m_varOrdering = {};		obj.m_coeff = 0;		obj.m_degree = -2147483648;		return;	end				% Other cases    degreeSum = 0;	for i = 1 : length(varOrdering)		degreeSum = degreeSum + length(varOrdering{i});    end	obj.m_varOrdering = varOrdering;	obj.m_coeff = coeff;	obj.m_degree = degreeSum;end