<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html xmlns="http://www.w3.org/TR/REC-html40"><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-1"><link rel=File-List href="index_files/filelist.xml"><title>Lecture 1 - Active Contours and Level Sets</title><link href="styles.css" rel="stylesheet" type="text/css"></head><body bgcolor="#FFFFFF" lang=FR><div >   <h1>Lecture 1 - Active Contours and Level Sets</h1></div><blockquote>   <blockquote>     <blockquote>       <blockquote>         <blockquote>          <p align="justify"><strong>Abstract : </strong>The goals of this lecture             is to use the level set framework in order to do curve evolution.             The mean curvature motion is the basic tool, and it can be extended             into edge-based (geodesic active contours) and region-based (Chan-Vese)             snakes. </p>        </blockquote>      </blockquote>    </blockquote>  </blockquote></blockquote><h2> Setting up Matlab. </h2><ul>  <li>First download the Matlab toolbox <a href="matlab/toolbox_fast_marching.zip"><font face="Courier New, Courier, mono">toolbox_fast_marching.zip</font></a>.     Unzip it into your working directory. You should have a directory toolbox_fast_marching/     in your path. </li>  <li>The first thing to do is to install this toolbox in your path.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">path(path, 'toolbox_fast_marching/');<br>      path(path, 'toolbox_fast_marching/data/');<br>      path(path, 'toolbox_fast_marching/toolbox/');</font></p>  </blockquote>  <li>Recompile the mex file for your machine (this can produce some warning).     If it does not work, either use the already compiled mex file (they should     be available in <font face="Courier New, Courier, mono">toolbox_fast_marching/</font>     for MacOs and Unix) or try to set up matlab with a C compiler (e.g. gcc) using     '<font face="Courier New, Courier, mono">mex -setup</font>'. </li>  <blockquote>     <p><font face="Courier New, Courier, mono">cd toolbox_fast_marching<br>      compile_mex;<br>      cd ..</font></p>  </blockquote>  </ul> <h2> Managing level set function. </h2> <ul>  <li>In order to perform curve evolution, we will deal with a distance function     stored in a 2D image D. The curve will be embedded in the level set D=0. This     curve will be evolved by modifying the image D. A curve evolution ODE can be     replaced by an PDE on D. This allows to deal with topological changes when     a curve split or two curves merge.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">n = 200; % size of the image<br>      % load a distance function<br>      D0 = compute_levelset_shape('circlerect2', n);<br>      % type 'help compute_levelset_shape' to see other <br>      % basic curve you can load.<br>      <br>      % display the curve<br>      clf; hold on;<br>      imagesc(D); axis image; axis off; axis([1 n 1 n]);<br>      [c,h] = contour(D,[0 0], 'r');<br>      set(h, 'LineWidth', 2);<br>      hold off;<br>      colormap gray(256);<br>      <br>      % do the union of two curves<br>      options.center = [0.15 0.15]*n;<br>      options.radius = 0.1*n;<br>      D1 = compute_levelset_shape('circle', n,options);<br>      imagesc(min(D0,D1)&lt;0);</font></p>  </blockquote>  <li>During the curve evolution, the image D might become far from being a distance     function. In order to stabilize the algorithm, one needs to re-compute this     distance function.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% here we simulate a modification       of the distance function<br>      [Y,X] = meshgrid(1:n,1:n);<br>      D = (D0.^3) .* (X+n/3); <br>      D1 = perform_redistancing(D);<br>      % display both the original and the new, <br>      % redistanced, curve (should be very close)<br>      ...</font></p>  </blockquote></ul><h2> Mean Curvature Motion. </h2><ul>  <li>In order to compute differential quantities (tangent, normal, curvature,     etc) on the curve, you can compute derivatives of the image D. </li>  <blockquote>     <p><font face="Courier New, Courier, mono">% the gradient<br>      g0 = divgrad(D);<br>      % display the gradient (as arrow field with 'quiver', ...)<br>      ...<br>      % the normalized gradient<br>      d = max(eps, sqrt(sum(g0.^2,3)) );<br>      g = g0 ./ repmat( d, [1 1 2] );<br>      % display<br>      ...<br>      % the curvature<br>      K = d .* divgrad( g );<br>      % display<br>      ...</font></p>  </blockquote>  <li>The mean curvature motion of the level sets of some image u is driven be     the following equation.<br>    <font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><img src="images/tp1b/eq-mean-curvature.png" width="250"><br>    Implement this evolution explicitly in time using finite differences.</li></ul><ul>  <blockquote>     <p><font face="Courier New, Courier, mono">Tmax = 1000; % maximum time of       evolution<br>      dt = 0.4; % time step (should be small)<br>      niter = round(Tmax/dt); % number of iterations<br>      D = D0; % initialization</font><font face="Courier New, Courier, mono"><br>      for i=1:niter<br>      &nbsp;&nbsp;&nbsp;&nbsp;% compute the right hand size of the PDE<br>      &nbsp;&nbsp;&nbsp;&nbsp;...<br>      &nbsp;&nbsp;&nbsp;&nbsp;% update the distance field<br>      &nbsp;&nbsp;&nbsp;&nbsp;D = ...;<br>      &nbsp;&nbsp;&nbsp;&nbsp;% redistance the function from time to time<br>      &nbsp;&nbsp;&nbsp;&nbsp;if mod(i,30)==0<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D = perform_redistancing(D);<br>      &nbsp;&nbsp;&nbsp;&nbsp;end <br>      &nbsp;&nbsp;&nbsp;&nbsp;% display from time to time<br>      &nbsp;&nbsp;&nbsp;&nbsp;if mod(i,30)=1<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% display here<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>      &nbsp;&nbsp;&nbsp;&nbsp;end <br>      end</font></p>  </blockquote>  <table width="1100" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1b/mean-01.png" width="200"/> <img src="images/tp1b/mean-02.png" width="200"/>         <img src="images/tp1b/mean-03.png" width="200"/> <img src="images/tp1b/mean-04.png" width="200"/>         <img src="images/tp1b/mean-05.png" width="200"/> </td>    </tr>    <tr>       <td align="center">Curve evolution under the mean curvature motion (the         background is the distance function D).</td>    </tr>  </table></ul><h2> Edge-based Segmentation with Geodesic Active Contour (snakes + level set). </h2><ul>  <li>Given a background image M to segment, one needs to compute an edge-stopping     function E. It should be small in area of high gradient, and high in area     of large gradient.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% load an image<br>      name = 'brain';<br>      M = rescale( sum( load_image(name, n), 3) );<br>      % display it<br>      ...<br>      % compute a smoothed gradient<br>      sigma = 4; % blurring size<br>      G = divgrad( perform_blurring(M,sigma) );<br>      % compute the norm of the gradient<br>      d = ...<br>      % compute the edge-stopping function<br>      E = ...<br>      % rescale it so that it is in realistic ranges<br>      E = rescale(E,0.3,1);</font></p>  </blockquote>  <li>The geodesic active contour evolution is a mean curvature motion modulated     by the edge-stopping function:<br>    <font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><img src="images/tp1b/eq-snake.png" width="350">     <br>    Implement this evolution explicitly in time using finite differences.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">...</font> </p>  </blockquote>  <table width="1100" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1b/snake-01.png" width="200"/> <img src="images/tp1b/snake-02.png" width="200"/>         <img src="images/tp1b/snake-03.png" width="200"/> <img src="images/tp1b/snake-04.png" width="200"/>         <img src="images/tp1b/snake-05.png" width="200"/> </td>    </tr>    <tr>       <td align="center">Segmentation with geodesic active contours.</td>    </tr>  </table></p>  </ul><h2> Region-based Segmentation with Chan-Vese (Mumord-Shah + level sets). </h2><ul>  <li>The geodesic active contour uses an edge-based energy. It has lots of local     minima and is very sensitive to initialization. In order to circumvent these     drawbacks, one can use a region based energy like the Mumford-Shah functional.     Re-casted into the level set framework, it reads:<br>    <font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><img src="images/tp1b/eq-chan-vese-def.png" width="550">     <br>    The corresponding gradient descent is the Chan-Vese active contour method:<br>    <font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><font face="Courier New, Courier, mono">&nbsp;&nbsp;&nbsp;&nbsp;</font><img src="images/tp1b/eq-chan-vese.png" width="520">     <br>    Implement this evolution explicitly in time using finite differences, when     c1 and c2 are known in advanced.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% initialize with a complex distance       function <br>      D0 = compute_levelset_shape('small-disks', n); <br>      % set parameters<br>      lambda = 0.8;<br>      c1 = ...; % black<br>      c2 = ...; % gray<br>      ...</font>     <table width="1100" border="0" cellspacing="0" cellpadding="0" align="center">      <tr align="center">         <td> <img src="images/tp1b/chan-vese-01.png" width="200"> <img src="images/tp1b/chan-vese-02.png" width="200">           <img src="images/tp1b/chan-vese-03.png" width="200"> <img src="images/tp1b/chan-vese-04.png" width="200">           <img src="images/tp1b/chan-vese-05.png" width="200"> </td>      </tr>      <tr>         <td align="center">Segmentation with Chan-Vese active contour without           edges. </td>      </tr>    </table>  </blockquote>  <li>In the case that one does not know in advance the constants c0 and c1, how     to update them automatically during the evolution ? Implement this method.</li>  <blockquote><br/>    Copyright &copy; 2006 <a href="http://www.cmap.polytechnique.fr/%7Epeyre/">Gabriel     Peyr&eacute;</a> </blockquote></ul></body></html>