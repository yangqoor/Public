<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html xmlns="http://www.w3.org/TR/REC-html40"><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-1"><link rel=File-List href="index_files/filelist.xml"><title>Lecture 2 - Front Propagation in 2D and 3D</title><link href="styles.css" rel="stylesheet" type="text/css"></head><body bgcolor="#FFFFFF" lang=FR><div >   <h1>Lecture 2 - Front propagation<br>    in 2D and 3D</h1></div><blockquote>   <blockquote>     <blockquote>       <blockquote>         <blockquote>          <p align="justify"><strong>Abstract : </strong>The goals of this lecture             is to manipulate the fast marching algorithm in 2D and 3D. Application             to shortest path extraction (e.g. road tracking and tubular structure extraction in medical images) and Voronoi cell segmentation             is presented.</p>        </blockquote>      </blockquote>    </blockquote>  </blockquote></blockquote><h2> Setting up Matlab. </h2><ul>  <li>First download the Matlab toolbox <a href="matlab/toolbox_fast_marching.zip"><font face="Courier New, Courier, mono">toolbox_fast_marching.zip</font></a>.     Unzip it into your working directory. You should have a directory toolbox_fast_marching/     in your path. </li>  <li>The first thing to do is to install this toolbox in your path.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">path(path, 'toolbox_fast_marching/');<br>      path(path, 'toolbox_fast_marching/data/');<br>      path(path, 'toolbox_fast_marching/toolbox/');</font></p>  </blockquote>  <li>Recompile the mex file for your machine (this can produce some warning).     If it does not work, either use the already compiled mex file (they should     be available in <font face="Courier New, Courier, mono">toolbox_fast_marching/</font>     for MacOs and Unix) or try to set up matlab with a C compiler (e.g. gcc) using     '<font face="Courier New, Courier, mono">mex -setup</font>'. </li>  <blockquote>     <p><font face="Courier New, Courier, mono">cd toolbox_fast_marching<br>      compile_mex;<br>      cd ..</font></p>  </blockquote>  </ul> <h2> Front propagation in 2D. </h2> <ul>  <li>We can now load an image and build a speed propagation function <font face="Courier New, Courier, mono">W</font>.     Note that area with <font face="Courier New, Courier, mono">W</font> values     near 0 (black pixels) are those in which the front propagate slowly, so that     <font face="Courier New, Courier, mono">W </font>is the inverse of the potential     that weight the metric.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">n = 128;<br>      name = 'cavern'; % other possibilities are 'mountain' and 'road2'<br>      W = load_image(name, n);<br>      W = rescale(W, 0.01, 1); % set up a reasonable range for the potential<br>      % display the weighting function</font><font face="Courier New, Courier, mono"><br>      clf; imagesc(W); colormap gray(256);</font> </p>  </blockquote>  <li>After asking to the user the starting and ending points, we proceed to the     front propagation. Note that the propagation terminates when the front reaches     the ending point.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">[start_points,end_points] = pick_start_end_point(W);<br>      options.end_points = end_points;<br>      [D,S] = perform_fast_marching_2d(W, start_points, options);<br>      % display the distance function<br>      clf; imagesc(D);<br>      D(I==Inf) = 0; % remove Inf values that make contour crash<br>      figure; contour(D,50); </font></p>  </blockquote>  <li>The shortest path is extracted by performing a gradient descent of D, starting     from the ending point.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">p = extract_path_2d(D,end_points,       options);</font> <font face="Courier New, Courier, mono"><br>      % display the path<br>      clf; plot_fast_marching_2d(W,S,p,start_points,end_points);</font></p>  </blockquote>  <li>Now that you know the basic commands, you can try other speed functions     loaded from other files, and you can try more complicated potential than just     the value of the image. You can try a potential based on the gradient of the     image computed using <font face="Courier New, Courier, mono">grad(W)</font>.</li></ul><ul>  <table width="1200" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/cavern-dist-function.jpg" width="300"/> <img src="images/tp1/cavern-dist-function-contour.jpg" width="300"/>         <img src="images/tp1/cavern-shortest-path-2d.jpg" width="300"/><br/> <img src="images/tp1/mountain-dist-function.jpg" width="300"/>         <img src="images/tp1/mountain-dist-func-cont.jpg" width="300"/> <img src="images/tp1/mountain-shortest-path-2d.jpg" width="300"/><br/>         <img src="images/tp1/road2-dist-function.jpg" width="300"/> <img src="images/tp1/road2-dist-function-contour.jpg" width="300"/>         <img src="images/tp1/road2-shortest-path-2d.jpg" width="300"/> </td>    </tr>    <tr>       <td align="center">Left : distance function for 3 different W maps. <br>        Center : the corresponding level set maps. <br>        Right : shortest path together with the explored area (in red).</td>    </tr>  </table></ul><h2> 3D Volumetric Shortest Paths. </h2><ul>  <li>     <div align="justify">Firs you need to load a 3D array of data <font face="Courier New, Courier, mono">M</font>.       Such a volumetric dataset is more difficult to visualize than a standard       2D image. You can render slices like <font face="Courier New, Courier, mono">M(:,:,i)</font>       or use a volumetric renderer such a <font face="Courier New, Courier, mono">vol3d</font>.       In order to do so, you need to set up a correct alpha mapping to make transparent       some parts of the volume. If you rotate the data, then you need to re-render       the volume using <font face="Courier New, Courier, mono">vol3d(h)</font>.       You can download the 3D data set <a href="matlab/brain1-crop-256.mat">here</a>.</div>  </li>  <blockquote>     <p><font face="Courier New, Courier, mono">% load the whole volume<br>      load brain1-crop-256.mat<br>      % crop to retain only the central part<br>      n = 100;<br>      M = rescale( crop(M,n) ); <br>      % display some horizontal slices<br>      imageplot(M(:,:,50));<br>      % same thing in the other directions<br>      ...</font></p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/brain-img-1.png" width="200"/> <img src="images/tp1/brain-img-2.png" width="200"/>         <img src="images/tp1/brain-img-3.png" width="200"/> <img src="images/tp1/brain-img-4.png" width="200"/>         <br/> <img src="images/tp1/brain-img-5.png" width="200"/> <img src="images/tp1/brain-img-6.png" width="200"/>         <img src="images/tp1/brain-img-7.png" width="200"/> <img src="images/tp1/brain-img-8.png" width="200"/>       </td>    </tr>    <tr>       <td align="center">Cross sections of the data-set.</td>    </tr>  </table>  <br>  <li>     <div align="justify">Another, more efficient way, to render volumetric data       is to display a semi-transparent volumetric image. This can be achieved       using the function <font face="Courier New, Courier, mono">vol3d</font>       than render semi-transparent slices of the data orthogonal to the viewing       direction. In order to do so, you need to set up a correct alpha mapping       to make transparent some parts of the volume. If you rotate the data, then       you need to re-render the volume using <font face="Courier New, Courier, mono">vol3d(h)</font>.</div>  </li>  <blockquote>     <p><font face="Courier New, Courier, mono">clf;<br>      h = vol3d('cdata',M,'texture','2D');<br>      view(3); axis off; <br>      % set up a colormap<br>      colormap bone(256);<br>      % set up an alpha map<br>      options.center = ...; % here a value in [0,1]<br>      options.sigma = .08; % control the width of the non-transparent region<br>      a = compute_alpha_map('gaussian', options); % you can plot(a) to see the       alphamap <br>      colormap bone(256);<br>      % refresh the rendering<br>      vol3d(h); <br>      % try with other alphamapping and colormapping<br>      ... </font></p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/brain-vol3d-1.png" width="300"/> <img src="images/tp1/brain-vol3d-2.png" width="300"/>         <img src="images/tp1/brain-vol3d-3.png" width="300"/><br/> <img src="images/tp1/brain-vol3d-4.png" width="300"/>         <img src="images/tp1/brain-vol3d-5.png" width="300"/> <img src="images/tp1/brain-vol3d-6.png" width="300"/>	      </td>    </tr>    <tr>       <td align="center">Volumetric rendering with different alpha-mapping. Each         time the<font face="Courier New, Courier, mono"> options.center</font>         value is increased.</td>    </tr>  </table>  <br>  <li>Geodesic distances can be computed on a 3D volume using the Fast Marching.     The important point here is to define the correct potential field W that should     be large in the region where you want the front to move fast. It means that     geodesic will follow these regions. In order to do so, we will ask the user     to click on a starting point in a given horizontal slice <font face="Courier New, Courier, mono">W(:,:,delta)</font>.     The potential is then computed in order to be large for value of <font face="Courier New, Courier, mono">M</font>     that are close to the value at this starting point.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% ask to the user for some input       point<br>      </font><font face="Courier New, Courier, mono">delta = 5;<br>      clf; imageplot(M(:,:,delta));<br>      title('Pick starting point');<br>      start_point = round( ginput(1) );<br>      start_point = [start_point(2); start_point(1); delta];<br>      % compute a potential that is high only very close <br>      % to the value of M at the selected point<br>      W = ...;<br>      W = rescale(W,.001,1);<br>      % perform the front propagation</font><font face="Courier New, Courier, mono"><br>      options.nb_iter_max = Inf;<br>      [D,S] = perform_fast_marching_3d(W, start_point, options);<br>      % display the results using vol3d<br>      ... </font> </p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/brain-front-1.png" width="240"/> <img src="images/tp1/brain-front-2.png" width="240"/>         <img src="images/tp1/brain-front-3.png" width="240"/> <img src="images/tp1/brain-front-5.png" width="240"/>       </td>    </tr>    <tr>       <td align="center">Exploration of the distance function using <font face="Courier New, Courier, mono">vol3d</font>.</td>    </tr>  </table>  <br/>  <li>In order to extract a geodesic, we need to select an ending point and perform     a descent of the distance function D from this starting point. The selection     is done by choosing a point of low distance value in the slice <font face="Courier New, Courier, mono">D(:,:,end-delta)</font>.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% extract a slice<br>      d = D(:,:,n-delta);<br>      % select the point (x,y) of minimum value of d<br>      % hint: use functions 'min' and 'ind2sub'<br>      ...<br>      [x,y] = ...;<br>      end_point = [x;y;n-delta];</font><font face="Courier New, Courier, mono"><br>      ... <br>      % extract the geodesic by discrete descent<br>      path = compute_discrete_geodesic(D,end_point);<br>      % draw the path<br>      Dend = D(end_point(1),end_point(2),end_point(3));<br>      D1 = double( D&lt;=Dend );<br>      clf;<br>      plot_fast_marching_3d(M,D1,path,start_point,end_point);</font> </p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/brain-geodesic-1.png" width="400"/> <img src="images/tp1/brain-geodesic-2.png" width="400"/>       </td>    </tr>    <tr>       <td align="center">Exploration of the distance function using <font face="Courier New, Courier, mono">vol3d</font>.<br>        The red surface indicates the region of the volume that has been explored<br>        before hitting the ending point.</td>    </tr>  </table></p>  </ul><h2> Voronoi segmentation and geodesic Delaunay triangulation in 2D. </h2><ul>  <li>With the same code as above, one can use multiple starting points. The function     perform_fast_marching_2d returns a segmentation map Q that contains the Voronoi     segmentation. </li>  <blockquote>     <p><font face="Courier New, Courier, mono">n=300;<br>      name = 'constant'; % other possibility is 'mountain'<br>      W = load_potential_map(name, n);<br>      m = 20; % number of center points<br>      % compute the starting point at random.<br>      start_points = floor( rand(2,m)*(n-1) ) +1;<br>      [D,Z,Q] = perform_fast_marching_2d(W, start_points);<br>      % display the sampling with the distance function<br>      clf; hold on;<br>      imagesc(D'); axis image; axis off;<br>      plot(start_points(1,:), start_points(2,:), '.');<br>      hold off;<br>      colormap gray(256); <br>      % display the segmentation<br>      figure; clf; hold on;<br>      imagesc(Q'); axis image; axis off;<br>      plot(start_points(1,:), start_points(2,:), '.');<br>      hold off;<br>      colormap gray(256); </font></p>  </blockquote>  <table width="900" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/constant-voronoi-dist.jpg" width="300"/> <img src="images/tp1/mountain-voronoi-dist.jpg" width="300"/>       </td>    </tr>    <tr>       <td align="center">Example of Voronoi cells (distance functions) obtained         with <br>        a constant speed W (left) and the mountain map (right).<br>        Note how the cell on the left have polygonal boundaries whereas cells on         the right<br>        have curvy boundaries.<br></td>    </tr>  </table>  <br>  <li>A geodesic Delaunay triangulation is obtained by linking starting points     whose Voronoi cells touch. This is the dual of the original Voronoi segmentation.</li>  <blockquote>     <p><br>      <font face="Courier New, Courier, mono">faces = compute_voronoi_triangulation(Q);<br>      hold on;<br>      imagesc(Q'); axis image; axis off;<br>      plot(start_points(1,:), start_points(2,:), 'b.', 'MarkerSize', 20);<br>      plot_edges(compute_edges(faces), start_points, 'k');<br>      hold off;<br>      axis tight; axis image; axis off;<br>      colormap jet(256);</font></p>  </blockquote>  <table width="900" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp1/constant-voronoi-tr.jpg" width="300"/> <img src="images/tp1/mountain-voronoi-tr.jpg" width="300"/>       </td>    </tr>    <tr>       <td align="center">Examples of triangulations. Notice how the canonical         euclidean Delaunay triangulation (left) <br>        differs from the geodesic one (right) when the metric is not constant.</td>    </tr>  </table></ul><h2> Farthest point sampling. </h2><ul>  <li>We are now back to computations in 2D. The function <font face="Courier New, Courier, mono">farthest_point_sampling</font>     iteratively compute the distance to the already computed set of points, and     add to the list (initialized as empty) the farthest point. You should read     the function so that you fully understand what it is doing. You can also try     different speed functions to see the resulting sampling.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">n=300;<br>      name = 'mountain';<br>      W = load_potential_map(name, n);<br>      % perform sampling<br>      landmark = [];<br>      landmark = farthest_point_sampling( W, landmark, nbr_landmarks-size(landmark,2)       );<br>      % display<br>      hold on;<br>      imagesc(M');<br>      plot(landmark(1,:), landmark(2,:), 'b.', 'MarkerSize', 20);<br>      hold off;<br>      axis tight; axis image; axis off;<br>      colormap gray(256);<br/>	% try with other metric W, like 'constant' <br>	...</font>     <table width="920" border="0" cellspacing="0" cellpadding="0" align="center">      <tr align="center">         <td> <img src="images/tp1/mountain-sampling-50.jpg" width="300"> <img src="images/tp1/mountain-sampling-100.jpg" width="300">           <img src="images/tp1/mountain-sampling-150.jpg" width="300"><br/> <img src="images/tp1/mountain-sampling-200.jpg" width="300">           <img src="images/tp1/mountain-sampling-250.jpg" width="300"> <img src="images/tp1/mountain-sampling-300.jpg" width="300">         </td>      </tr>      <tr>         <td align="center">Farthest point sampling with 50, 100, 150, 200, 250 and           <br>          300 points respectively. </td>      </tr>    </table>  </blockquote>  <li>Now you can compute the corresponding triangulation using the already given     code. </li>  <blockquote>     <table width="920" border="0" cellspacing="0" cellpadding="0" align="center">      <tr align="center">         <td> <img src="images/tp1/mountain-sampling-tr-100.jpg" width="300"> <img src="images/tp1/mountain-sampling-tr-200.jpg" width="300">           <img src="images/tp1/mountain-sampling-tr-300.jpg" width="300"> </td>      </tr>      <tr>         <td align="center">Farthest point triangulations. </td>      </tr>    </table>  </blockquote></ul><h2>Heuristically driven front propagation. </h2><ul>  <li>The function perform_fast_marching_2d can be used with a fourth argument     that gives an estimation of the distance to the end point. It helps the algorithm     to reduce the number of explored pixels. This remaining distance H should     be estimated quickly (hence the name &quot;heuristic&quot;). Here we propose     to cheat and use directly the true remaining distance using a classical propagation.     You have to test this code with various values of <font face="Courier New, Courier, mono">weight</font>.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">[start_points,end_points] = pick_start_end_point(W);<br>      % compute the heuristic<br>      [H,S] = perform_fast_marching_2d(W, end_points);<br>      % perform the propagation<br>      options.end_points = end_points;<br>      weight = 0.5; % should be between 0 and 1.<br>      [D,S] = perform_fast_marching_2d(W, start_points, options, H*weight);<br>      % compute the path<br>      p = extract_path_2d(D,end_points, options);<br>      % display<br>      clf;<br>      plot_fast_marching_2d(W,S,p,start_points,end_points);<br>      colormap jet(256);<br>      saveas(gcf, [rep name '-heuristic' num2str(weight) '.jpg'], 'jpg');</font>   </blockquote>  <li>As a final question, try to devise a fast way to estimate the remaining     distance function. If you have no idea, you can use the function <font face="Courier New, Courier, mono">perform_fmstar_2d</font>     which implement two methods to achieve this.</li>  <table width="1200" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td><img src="images/tp1/road2-heuristic0.jpg" width="300"/> <img src="images/tp1/road2-heuristic0.5.jpg" width="300"/>         <img src="images/tp1/road2-heuristic0.9.jpg" width="300"/> </td>    </tr>    <tr>       <td align="center">Heuristic front propagation with a weight parameter of         0, 0.5 and 0.9 respectively.<br>        Notice how the explored area shrinks around the true path.</td>    </tr>  </table>  <br/>  Copyright &copy; 2006 <a href="http://www.cmap.polytechnique.fr/%7Epeyre/">Gabriel   Peyr&eacute;</a> </ul></body></html>