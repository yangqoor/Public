<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html xmlns="http://www.w3.org/TR/REC-html40"><head><meta http-equiv=Content-Type content="text/html; charset=iso-8859-1"><link rel=File-List href="index_files/filelist.xml"><title>Lecture 4 - Mesh Processing</title><link href="styles.css" rel="stylesheet" type="text/css"></head><body bgcolor="#FFFFFF" lang=FR><div >   <h1>Lecture 4 - Mesh Processing</h1></div><blockquote>   <blockquote>     <blockquote>       <blockquote>         <blockquote>          <p align="justify"><strong>Abstract : </strong>The goal of this lecture             is to manipulate a 3D mesh. This includes the loading and display             of a 3D mesh and then the processing of the mesh. This processing             is based on computations involving various kinds of Laplacians. These             Laplacians are extensions of the classical second order derivatives             to 3D meshes. They can be used to perform heat diffusion (smoothing),             compression and parameterization of the mesh.</p>        </blockquote>      </blockquote>    </blockquote>  </blockquote></blockquote><h2> Setting up Matlab. </h2><ul>  <li>First download the Matlab toolbox <a href="matlab/toolbox_graph.zip"><font face="Courier New, Courier, mono">toolbox_graph.zip</font></a>.     Unzip it into your working directory. You should have a directory <font face="Courier New, Courier, mono">toolbox_graph</font>/     in your path. Download also the set of additional meshes in .off format: <a href="matlab/meshes.zip">meshes.zip</a>     and unzip this file into your directory.</li>  <li>The first thing to do is to install this toolbox in your path.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">path(path, 'toolbox_graph/');<br>      path(path, 'toolbox_graph/off/');<br>      path(path, 'toolbox_graph/toolbox/');<br>      path(path, 'meshes/'); </font></p>  </blockquote>  <li>Recompile the mex file for your machine (this can produce some warning).     If it does not work, either use the already compiled mex file (they should     be available in <font face="Courier New, Courier, mono">toolbox_graph/</font>     for MacOs and Unix) or try to set up matlab with a C compiler (e.g. gcc) using     '<font face="Courier New, Courier, mono">mex -setup</font>'. </li>  <blockquote>     <p><font face="Courier New, Courier, mono">cd toolbox_graph<br>      compile_mex;<br>      cd ..</font></p>  </blockquote></ul> <h2> Mesh Loading and Displaying. </h2> <ul>  <li>You can load a mesh from a file and display it. Remember that a mesh is     given by two matrix: <font face="Courier New, Courier, mono">vertex</font>     store the 3D vertex positions and <font face="Courier New, Courier, mono">face</font>     store 3-tuples giving the number of the vertices forming faces.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">name = 'mushroom'; % other possibilities       include 'venus'<br>      %load from file<br>      [vertex,face] = read_mesh([name '.off']);<br>      % display the mesh<br>      clf;<br>      plot_mesh(vertex,face);<br>      % remove the display of the triangle<br>      shading interp; camlight; </font></p>  </blockquote>  <table width = "0" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp3/venus-mesh-display.jpg" height="300"/> <img src="images/tp3/mushroom-mesh-display.jpg" height="300"/>       </td>    </tr>    <tr>       <td align="center">Two examples of rendered triangle meshes.</td>    </tr>  </table>  <li>A mesh can also be built by starting from a coarse triangulation and then     subdividing it.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">name = 'sphere'; % another choice       could be 'L1'<br>      j = 2; % number of subdivision levels<br>      [vertex,face] = gen_base_mesh(name, 0); % the initial mesh<br>      [vertex,face] = gen_base_mesh(name, j);<br>      clf;<br>      plot_mesh(vertex,face);</font></p>  </blockquote>  <table width = "1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp3/sphere-subd-0.jpg" height="200"/> <img src="images/tp3/sphere-subd-1.jpg" height="200"/>         <img src="images/tp3/sphere-subd-2.jpg" height="200"/> <img src="images/tp3/sphere-subd-3.jpg" height="200"/><br/>         <img src="images/tp3/L1-subd-0.jpg" height="200"/> <img src="images/tp3/L1-subd-1.jpg" height="200"/>         <img src="images/tp3/L1-subd-2.jpg" height="200"/> <img src="images/tp3/L1-subd-3.jpg" height="200"/>       </td>    </tr>    <tr>       <td align="center">Two example of meshes computed by regular subdivision.</td>    </tr>  </table></ul><h2> Heat Diffusion on 3D Meshes. </h2><ul>  <li>A Laplacian on a 3D mesh is a (n,n) matrix L, where n is the number of vertices,     that generalize the classical laplacian of image processing to a 3D mesh.     There are several forms of laplacian depending whether it is symmetric (L'=L)     and normalized (1 on the diagonal) :<br>    <table width="70%" align="center" border="0">      <tr>         <td width="10%">&nbsp;</td>        <td>L0 = D + W </td>        <td><em>(symmetric, normalized)</em></td>      </tr>      <tr>         <td>&nbsp;</td>        <td>L1 = D^{-1}*L0 = Id + D^{-1}*W</td>        <td><em> (non-symmetric, non-normalized)</em></td>      </tr>      <tr>         <td>&nbsp;</td>        <td>L2 = D^{-1/2}*L0*D^{-1/2} = Id + D^{-1/2}*W*D^{-1/2}<em> </em></td>        <td><em>(symmetric, normalized)</em></td>      </tr>    </table>    Where W is a weight matrix, W(i,j)=0 if (i,j) is not an edge of the graph.     There are several kinds of such weights<br>    <table width="70%" align="center" border="0">      <tr>         <td width="10%">&nbsp;</td>        <td>W(i,j)=1</td>        <td><em>(combinatorial)</em></td>      </tr>      <tr>         <td>&nbsp;</td>        <td>W(i,j)=1/|vi-vj|^2</td>        <td><em>(distance)</em></td>      </tr>      <tr>         <td>&nbsp;</td>        <td>W(i,j)=cot(alpha_ij)+cot(beta_ij)<em> </em></td>        <td><em>(harmonic)</em></td>      </tr>    </table>    where {vi}_i are the vertex of the mesh, i.e. vi=vertex(:,i), and (alpha_ij,beta_ij)     is the pair of adjacent angles to the edge (vi,vj). A gradient matrix G associated     to the laplacian L is an (m,n) matrix where m is the number of edges in the     mesh, that satisfies L=G'*G. It can be computed as G((i,j),k)=+sqrt(W(i,j))     if k=j and G((i,j),k)=-sqrt(W(i,j)) if k=i, and G((i,j),k)=0 otherwise.</li>  <li>In the following, you can compute gradient, weights and laplacian using     the compute_mesh_xxx functions.<br>  </li>  <blockquote>     <p><font face="Courier New, Courier, mono">% kind of laplacian, can be 'combinatorial',       'distance' or 'conformal' (slow)<br>      laplacian_type = ...;<br>      % load two different kind of laplacian and check the gradient factorization<br>      options.symmetrize = 1;<br>      options.normalize = 0;<br>      L0 = compute_mesh_laplacian(vertex,face,laplacian_type,options);<br>      G0 = compute_mesh_gradient(vertex,face,laplacian_type,options);<br>      disp(['Error (should be 0): ' num2str(norm(L0-G0'*G0, 'fro')) '.']);<br>      options.normalize = 1;<br>      L1 = compute_mesh_laplacian(vertex,face,laplacian_type,options);<br>      G1 = compute_mesh_gradient(vertex,face,laplacian_type,options);<br>      disp(['Error (should be 0): ' num2str(norm(L1-G1'*G1, 'fro')) '.']);<br>      % these matrices are stored as sparse matrix<br>      spy(L0); </font></p>  </blockquote>  <li>In order to smooth a vector f of size n (i.e. a function defined on each     vertex of the mesh), one can perform a heat diffusion by solving the following     PDE<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d F / dt = -L*f &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F(x,t=0)=f <br>    until some stopping time t.<br>    When this diffusion is applied to each component of the positions of the vertices     f=vertex(i,:), this smoothes the 3D mesh. Implement this PDE using an explicit     discretization in time.<br>  </li>  <blockquote>     <p><font face="Courier New, Courier, mono">% the time step should be small       enough<br>      dt = 0.1;<br>      % stopping time<br>      Tmax = 10;<br>      % number of steps<br>      niter = round(Tmax/dt);<br>      % initialize the 3 vectors at time t=0<br>      vertex1 = vertex;<br>      % solve the diffusion<br>      for i=1:niter<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% update the position by       solving the PDE<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex1 = vertex1 + ...;<br>      end </font></p>  </blockquote>  <table width="900" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp3/smoothing-elephant.png" width="800"/> <img src="images/tp3/smoothing-bunny.png" width="800"/>         <img src="images/tp3/smoothing-skull.png" width="800"/> </td>    </tr>    <tr>       <td align="center">Heat diffusion on a 3D mesh, at times t=0, t=10, t=40,         t=200.</td>    </tr>  </table>  <li>Another way to smooth a mesh is to perform the following quadratic regularization     for each componnent f=vertex(i,:)<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F = argmin_g |f-g|^2     + t * |G*f|^2<br>    The solution of this optimization is given in closed form using the Laplacian     L=G'*G as the solution of the following linear system:<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Id+t*L)*F = f<br>    Solve this problem for various t on a 3D mesh. You can use the operator \     to solve a system. How does this method compares with the heat diffusion ?<br>  </li>  <blockquote>     <p><font face="Courier New, Courier, mono">% solve the equation<br>      vertex1 = ...;<br>      % display<br>      ...</font></p>  </blockquote></ul><h2> Combinatorial Laplacian: Spectral Decomposition and Compression. </h2><ul>  <li>The combinatorial laplacian is a linear operator (thus a NxN matrix where     N is the number of vertices). It depends only on the connectivity of the mesh,     thus on <font face="Courier New, Courier, mono">face</font> only. The eigenvector     of this matrix (which is symmetric, thus can be decomposed by SVD) forms an     orthogonal basis of the vector space of signal of NxN values (one real value     per vertex). Those functions are the extension of the Fourier oscillating functions     to surfaces. </li>  <blockquote>     <p><font face="Courier New, Courier, mono">% combinatorial laplacian computation       <br>      options.symmetrize = 1;<br>      options.normalize = 0;<br>      L0 = compute_mesh_laplacian(vertex,face,'combinatorial',options);<br>      %% Performing eigendecomposition<br>      [U,S,V] = svd(L0);<br>      % extract one of the eigenvectors<br>      c = U(:,end-10); % you can try with other vector with higher frequencies<br>      % assign a color to each vertex<br>      options.face_vertex_color = rescale(c, 0,255);<br>      % display<br>      clf;<br>      plot_mesh(vertex,face, options);<br>      </font><font face="Courier New, Courier, mono">shading interp; lighting       none; </font></p>  </blockquote>  <table width="1100" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp3/L1-eigv-1.jpg" height="200"/> <img src="images/tp3/L1-eigv-3.jpg" height="200"/>         <img src="images/tp3/L1-eigv-5.jpg" height="200"/> <img src="images/tp3/L1-eigv-7.jpg" height="200"/><br/>         <img src="images/tp3/sphere-eigv-1.jpg" height="200"/> <img src="images/tp3/sphere-eigv-3.jpg" height="200"/>         <img src="images/tp3/sphere-eigv-5.jpg" height="200"/> <img src="images/tp3/sphere-eigv-7.jpg" height="200"/><br/>         <img src="images/tp3/mushroom-eigv-1.jpg" height="180"/> <img src="images/tp3/mushroom-eigv-3.jpg" height="180"/>         <img src="images/tp3/mushroom-eigv-5.jpg" height="180"/> <img src="images/tp3/mushroom-eigv-7.jpg" height="180"/>       </td>    </tr>    <tr>       <td align="center">Eigenvectors of the combinatorial laplacian with <br>        increasing frequencies from left to right.<br></td>    </tr>  </table>  <br>  <li>Like the Fourier basis, the laplacian eigenvector basis can be used to perform     an orthogonal decomposition of a function. In order to perform mesh compression,     we decompose each coordinate X/Y/Z of the mesh into this basis. Once this     decomposition has been performed, a compression is achieved by keeping only     the biggest coefficients (in magnitude).</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% Warning : vertex should be of       size 3 x nvert<br>      keep = 5; % number of percents of coefficients kept<br>      vertex2 = (U'*vertex')'; % projection of the vector in the laplacian basis<br>      % set threshold to remove coefficients<br>      vnorm = sum(vertex2.^2, 1);<br>      vnorms = sort(vnorm); vnorms = vnorms(end:-1:1);<br>      nvert = size(vertex,2);<br>      thresh = vnorms( round(keep/100*nvert) );<br>      % remove small coefs by thresholding<br>      vertex2 = vertex2 .* repmat( vnorm&gt;=thresh, [3 1] ); <br>      % reconstruction<br>      vertex2 = (U*vertex2')';<br>      % display<br>      clf;<br>      plot_mesh(vertex2,face);<br>      shading interp; camlight;<br>      axis tight;</font></p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp3/venus-compress-1.jpg" height="300"/> <img src="images/tp3/venus-compress-3.jpg" height="300"/>         <img src="images/tp3/venus-compress-5.jpg" height="300"/> <img src="images/tp3/venus-compress-7.jpg" height="300"/>         <br/> <img src="images/tp3/mushroom-compress-1.jpg" height="160"/> <img src="images/tp3/mushroom-compress-3.jpg" height="160"/>         <img src="images/tp3/mushroom-compress-5.jpg" height="160"/> <img src="images/tp3/mushroom-compress-7.jpg" height="160"/>       </td>    </tr>    <tr>       <td align="center">Spectral mesh compression performed<br>        by decomposition on the eigenvectors of the laplacian.</td>    </tr>  </table></ul><h2> Mesh Flattening and Parameterization. </h2><ul>  <li>The eigenvector of the combinatorial laplacian can also be used to perform     mesh flattening. Flattening means finding a 2D location for each vertex of     the mesh. These two coordinates are composed by the eigenvectors n&deg;2 and     n&deg;3 of the laplacian.</li>  <blockquote>     <p> <font face="Courier New, Courier, mono">% load a mesh<br>      name = 'nefertiti';<br>      [vertex,face] = read_mesh([name '.off']);<br>      A = triangulation2adjacency(face);<br>      % perform the embedding using the combinatorial eigendecomposition<br>      xy = perform_spectral_embedding(2,A); <br>      % display the flattened mesh<br>      gplot(A,xy,'k.-');<br>      axis tight; axis square; axis off; </font></p>  </blockquote>  <li>This combinatorial flattening does not use geometric information since it     only use the connectivity of the mesh. So any mesh with the same connectivity     will have the same 2D embedding. In order to improve the quality of the embedding,     one can use a conformal laplacian, who approximate the Laplace Beltrami operator     of the continuous underlying surface.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% this time, we use the information       from vertex to compute flattening<br>      xy = perform_spectral_embedding(2,A,vertex,face);<br>      % display<br>      gplot(A,xy,'k.-');<br>      axis tight; axis square; axis off; </font></p>  </blockquote>  <li>Another way to compute the flattening is to use the Isomap algorithm. This     algorithm is not based on local differential operator such as laplacian. Instead,     the geodesic distance between points on the mesh graph is first computed (see     the <a href="tp4.html">course 4</a> for example of geodesic computations on     graphs). Then the 2D layout of point is computed in order to match the geodesic     distance with the distance in the plane.</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% the embedding is now computed       with isomap<br>      xy = perform_spectral_embedding(2,A,vertex);<br>      % display<br>      gplot(A,xy,'k.-');<br>      axis tight; axis square; axis off; </font></p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td>	  	<img src="images/tp3/nefertiti-original.jpg" height="200"> 	  	<img src="images/tp3/nefertiti-flat-combi.jpg" height="200"> 	  	<img src="images/tp3/nefertiti-flat-confo.jpg" height="200">         <img src="images/tp3/nefertiti-flat-isomap.jpg" height="200"> </td>    </tr>    <tr>       <td align="center"><p>Comparison of the flattening obtained with the combinatorial           laplacian,<br>          the conformal laplacian and isomap.<br>        </p></td>    </tr>  </table>  <br/>  <li>Mesh parameterization is similar to flattening, except that we fix the boundary     of the mesh to be flattened onto some given convex 2D curve. The flattening     can then be proved to be 1:1 (no triangle flip) and long as the curve is convex     and Id+laplacian is positive. While flattening involve spectral computation     (eigenvectors extraction), which is very slow, mesh parameterization involve     the solution of a sparse linear system, which is quite fast (even if the Laplacian     matrix is ill-conditioned).</li>  <blockquote>     <p><font face="Courier New, Courier, mono">% pre-compute 1-ring, i.e. the neighbors       of each triangle.<br>      ring = compute_1_ring(face);<br>      lap_type = 'combinatorial'; % the other choice is 'conformal'<br>      boundary_type = 'circle'; % the other choices are 'square' and 'triangle'<br>      % compute the parameterization by solving a linear system<br>      xy = compute_parametrization(vertex,face,lap_type,boundary_type,ring);<br>      % display<br>      clf;<br>      gplot(A,xy,'k.-');<br>      axis tight; axis square; axis off;</font></p>  </blockquote>  <table width="1000" border="0" cellspacing="0" cellpadding="0" align="center">    <tr align="center">       <td> <img src="images/tp3/nefertiti-param-ccomb.jpg" width="250"> <img src="images/tp3/nefertiti-param-scomb.jpg" width="250">         <img src="images/tp3/nefertiti-param-tcomb.jpg" width="250"> <br/> <img src="images/tp3/nefertiti-param-cconf.jpg" width="250">         <img src="images/tp3/nefertiti-param-sconf.jpg" width="250"> <img src="images/tp3/nefertiti-param-tconf.jpg" width="250">       </td>    </tr>    <tr>       <td align="center">The first row shows parameterization using the combinatorial         laplacian<br>        (with various boundary conditions). This assumes that the edge lengths         is 1.<br>        To take into account the geometry of the mesh, the second<br>        row uses the conformal laplacian.</td>    </tr>  </table>  <br/>    Copyright &copy; 2006 <a href="http://www.cmap.polytechnique.fr/%7Epeyre/">Gabriel   Peyr&eacute;</a> </ul></body></html>